from __future__ import annotations
import typing
import usdrt.Gf._Gf
import usdrt.Sdf._Sdf
import usdrt.helpers._helpers
__all__: list[str] = ['APISchemaBase', 'Access', 'AttrSpec', 'Attribute', 'ClipsAPI', 'CollectionAPI', 'ListPosition', 'ModelAPI', 'Overwrite', 'Prim', 'PrimRange', 'Read', 'ReadWrite', 'Relationship', 'SchemaBase', 'SchemaRegistry', 'Stage', 'TimeCode', 'Tokens', 'Typed', 'UsdCollectionMembershipQuery']
class APISchemaBase(SchemaBase):
    @staticmethod
    def GetSchemaTypeName() -> TfToken:
        ...
    def __bool__(self) -> bool:
        ...
    def __repr__(self) -> str:
        ...
class Access:
    """
    Members:
    
      Read
    
      ReadWrite
    
      Overwrite
    """
    Overwrite: typing.ClassVar[Access]  # value = <Access.Overwrite: 3>
    Read: typing.ClassVar[Access]  # value = <Access.Read: 1>
    ReadWrite: typing.ClassVar[Access]  # value = <Access.ReadWrite: 2>
    __members__: typing.ClassVar[dict[str, Access]]  # value = {'Read': <Access.Read: 1>, 'ReadWrite': <Access.ReadWrite: 2>, 'Overwrite': <Access.Overwrite: 3>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class AttrSpec:
    def __init__(self, arg0: tuple[usdrt.Sdf._Sdf.ValueTypeName, TfToken, Access]) -> None:
        ...
class Attribute:
    def AddConnection(self, source: usdrt.Sdf._Sdf.Path, position: ListPosition = ...) -> bool:
        ...
    def ClearConnections(self) -> bool:
        ...
    def Get(self, time: TimeCode = ...) -> typing.Any:
        ...
    def GetBaseName(self) -> TfToken:
        ...
    def GetConnections(self) -> list[usdrt.Sdf._Sdf.Path]:
        ...
    def GetName(self) -> TfToken:
        ...
    def GetNamespace(self) -> TfToken:
        ...
    def GetPath(self) -> usdrt.Sdf._Sdf.Path:
        ...
    def GetPrim(self) -> Prim:
        ...
    def GetPrimPath(self) -> usdrt.Sdf._Sdf.Path:
        ...
    def GetStage(self) -> Stage:
        ...
    def GetTypeName(self) -> usdrt.Sdf._Sdf.ValueTypeName:
        ...
    def HasAuthoredConnections(self) -> bool:
        ...
    def HasAuthoredValue(self) -> bool:
        ...
    def HasValue(self) -> bool:
        ...
    def InvalidateCpuData(self) -> bool:
        """
        Invalidate CPU data (for debugging)
        """
    def InvalidateGpuData(self) -> bool:
        """
        Invalidate GPU data (for debugging)
        """
    def IsCpuDataValid(self) -> bool:
        """
        Check if Fabric CPU data is currently valid
        """
    def IsGpuDataValid(self) -> bool:
        """
        Check if Fabric GPU data is currently valid
        """
    def IsValid(self) -> bool:
        ...
    def RemoveConnection(self, source: usdrt.Sdf._Sdf.Path) -> bool:
        ...
    def Set(self, value: typing.Any, time: TimeCode = ...) -> bool:
        ...
    def SetConnections(self, sources: list[usdrt.Sdf._Sdf.Path]) -> bool:
        ...
    def SplitName(self) -> list[str]:
        ...
    def SyncDataToCpu(self) -> bool:
        """
        Force a sync to CPU memory from GPU memory (for debugging)
        """
    def SyncDataToGpu(self) -> bool:
        """
        Force a sync to GPU memory from CPU memory (for debugging)
        """
    def __bool__(self) -> bool:
        ...
    def __repr__(self) -> str:
        ...
class ClipsAPI(APISchemaBase):
    @staticmethod
    def GetSchemaTypeName() -> TfToken:
        ...
    def __bool__(self) -> bool:
        ...
    @typing.overload
    def __init__(self, arg0: Prim) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: SchemaBase) -> None:
        ...
    def __repr__(self) -> str:
        ...
class CollectionAPI(APISchemaBase):
    @staticmethod
    def Apply(prim: Prim, name: TfToken) -> CollectionAPI:
        ...
    @staticmethod
    def ComputeIncludedPaths(query: UsdCollectionMembershipQuery, stageId: usdrt.helpers._helpers.StageReaderWriterId) -> set[usdrt.Sdf._Sdf.Path]:
        ...
    @staticmethod
    def GetSchemaTypeName() -> TfToken:
        ...
    @staticmethod
    def IsCollectionAPIPath(path: usdrt.Sdf._Sdf.Path, name: TfToken) -> bool:
        ...
    @staticmethod
    @typing.overload
    def sComputeMembershipQuery(stageId: usdrt.helpers._helpers.StageReaderWriterId, collectionPath: usdrt.Sdf._Sdf.Path) -> UsdCollectionMembershipQuery:
        ...
    @staticmethod
    @typing.overload
    def sComputeMembershipQuery(stageId: usdrt.helpers._helpers.StageReaderWriterId, collectionPath: usdrt.Sdf._Sdf.Path, query: UsdCollectionMembershipQuery) -> None:
        ...
    @typing.overload
    def ComputeMembershipQuery(self) -> UsdCollectionMembershipQuery:
        ...
    @typing.overload
    def ComputeMembershipQuery(self, arg0: UsdCollectionMembershipQuery) -> None:
        ...
    def CreateExcludesRel(self) -> Relationship:
        ...
    def CreateExpansionRuleAttr(self) -> Attribute:
        ...
    def CreateIncludeRootAttr(self) -> Attribute:
        ...
    def CreateIncludesRel(self) -> Relationship:
        ...
    def ExcludePath(self, pathToExclude: usdrt.Sdf._Sdf.Path) -> bool:
        ...
    def GetCollectionPath(self) -> usdrt.Sdf._Sdf.Path:
        ...
    def GetExcludesRel(self) -> Relationship:
        ...
    def GetExpansionRuleAttr(self) -> Attribute:
        ...
    def GetIncludeRootAttr(self) -> Attribute:
        ...
    def GetIncludesRel(self) -> Relationship:
        ...
    def GetName(self) -> TfToken:
        ...
    def IncludePath(self, pathToInclude: usdrt.Sdf._Sdf.Path) -> bool:
        ...
    def __bool__(self) -> bool:
        ...
    @typing.overload
    def __init__(self, arg0: Prim, arg1: TfToken) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: SchemaBase, arg1: TfToken) -> None:
        ...
    def __repr__(self) -> str:
        ...
class ListPosition:
    """
    Members:
    
      ListPositionFrontOfPrependList
    
      ListPositionBackOfPrependList
    
      ListPositionFrontOfAppendList
    
      ListPositionBackOfAppendList
    """
    ListPositionBackOfAppendList: typing.ClassVar[ListPosition]  # value = <ListPosition.ListPositionBackOfAppendList: 3>
    ListPositionBackOfPrependList: typing.ClassVar[ListPosition]  # value = <ListPosition.ListPositionBackOfPrependList: 1>
    ListPositionFrontOfAppendList: typing.ClassVar[ListPosition]  # value = <ListPosition.ListPositionFrontOfAppendList: 2>
    ListPositionFrontOfPrependList: typing.ClassVar[ListPosition]  # value = <ListPosition.ListPositionFrontOfPrependList: 0>
    __members__: typing.ClassVar[dict[str, ListPosition]]  # value = {'ListPositionFrontOfPrependList': <ListPosition.ListPositionFrontOfPrependList: 0>, 'ListPositionBackOfPrependList': <ListPosition.ListPositionBackOfPrependList: 1>, 'ListPositionFrontOfAppendList': <ListPosition.ListPositionFrontOfAppendList: 2>, 'ListPositionBackOfAppendList': <ListPosition.ListPositionBackOfAppendList: 3>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class ModelAPI(APISchemaBase):
    @staticmethod
    def GetSchemaTypeName() -> TfToken:
        ...
    def __bool__(self) -> bool:
        ...
    @typing.overload
    def __init__(self, arg0: Prim) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: SchemaBase) -> None:
        ...
    def __repr__(self) -> str:
        ...
class Prim:
    def AddAppliedSchema(self, appliedSchemaName: TfToken) -> bool:
        ...
    def ApplyAPI(self, schemaIdentifier: TfToken, instanceName: TfToken = '') -> bool:
        ...
    def ClearTypeName(self) -> bool:
        ...
    def CreateAttribute(self, name: TfToken, typeName: usdrt.Sdf._Sdf.ValueTypeName, custom: bool) -> ...:
        ...
    def CreateRelationship(self, relName: TfToken, custom: bool = True) -> ...:
        ...
    def GetAllChildren(self, prefetchFromUsd: bool = True) -> list[Prim]:
        ...
    def GetAllChildrenNames(self, prefetchFromUsd: bool = True) -> list[TfToken]:
        ...
    def GetAppliedSchemas(self) -> list[TfToken]:
        ...
    def GetAttribute(self, name: TfToken) -> ...:
        ...
    def GetAttributes(self) -> list[...]:
        ...
    def GetAuthoredAttributes(self) -> list[...]:
        ...
    def GetAuthoredPropertyNames(self) -> list[TfToken]:
        ...
    def GetAuthoredRelationships(self) -> list[...]:
        ...
    def GetChild(self, name: TfToken, prefetchFromUsd: bool = True) -> Prim:
        ...
    def GetChildren(self, prefetchFromUsd: bool = True) -> list[Prim]:
        ...
    def GetChildrenNames(self, prefetchFromUsd: bool = True) -> list[TfToken]:
        ...
    def GetName(self) -> TfToken:
        ...
    def GetNextSibling(self, prefetchFromUsd: bool = True) -> Prim:
        ...
    def GetParent(self, prefetchFromUsd: bool = True) -> Prim:
        ...
    def GetPath(self) -> usdrt.Sdf._Sdf.Path:
        ...
    def GetPrim(self) -> Prim:
        ...
    def GetPrimPath(self) -> usdrt.Sdf._Sdf.Path:
        ...
    def GetPropertyNames(self) -> list[TfToken]:
        ...
    def GetRelationship(self, relName: TfToken) -> ...:
        ...
    def GetRelationships(self) -> list[...]:
        ...
    def GetStage(self) -> Stage:
        ...
    def GetTypeName(self) -> TfToken:
        ...
    def HasAPI(self, schemaIdentifier: TfToken, instanceName: TfToken = '') -> bool:
        ...
    def HasAttribute(self, name: TfToken) -> bool:
        ...
    def HasAuthoredTypeName(self) -> bool:
        ...
    def HasProperty(self, propName: TfToken) -> bool:
        ...
    def HasRelationship(self, relName: TfToken) -> bool:
        ...
    @typing.overload
    def IsA(self, schemaType: typing.Any) -> bool:
        ...
    @typing.overload
    def IsA(self, schemaTypeName: TfToken) -> bool:
        ...
    def IsValid(self) -> bool:
        ...
    def RemoveAPI(self, schemaIdentifier: TfToken, instanceName: TfToken = '') -> bool:
        ...
    def RemoveAppliedSchema(self, appliedSchemaName: TfToken) -> bool:
        ...
    def RemoveProperty(self, propName: TfToken) -> bool:
        ...
    def SetTypeName(self, typeName: TfToken) -> bool:
        ...
    def __bool__(self) -> bool:
        ...
    def __repr__(self) -> str:
        ...
class PrimRange:
    __hash__: typing.ClassVar[None] = None
    def IsValid(self) -> bool:
        """
        true if the iterator is not yet exhausted
        """
    def __bool__(self) -> bool:
        ...
    def __eq__(self, arg0: PrimRange) -> bool:
        ...
    @typing.overload
    def __init__(self, arg0: Prim) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: UsdPrimRange) -> None:
        ...
    def __iter__(self) -> ...:
        ...
    def __ne__(self, arg0: PrimRange) -> bool:
        ...
    def __repr__(self) -> str:
        ...
class Relationship:
    def AddTarget(self, target: usdrt.Sdf._Sdf.Path, position: ListPosition = ...) -> bool:
        ...
    def ClearTargets(self, removeSpec: bool) -> bool:
        ...
    def GetBaseName(self) -> TfToken:
        ...
    def GetForwardedTargets(self) -> list[usdrt.Sdf._Sdf.Path]:
        ...
    def GetName(self) -> TfToken:
        ...
    def GetNamespace(self) -> TfToken:
        ...
    def GetPath(self) -> usdrt.Sdf._Sdf.Path:
        ...
    def GetPrim(self) -> Prim:
        ...
    def GetPrimPath(self) -> usdrt.Sdf._Sdf.Path:
        ...
    def GetStage(self) -> Stage:
        ...
    def GetTargets(self) -> list[usdrt.Sdf._Sdf.Path]:
        ...
    def HasAuthoredTargets(self) -> bool:
        ...
    def IsValid(self) -> bool:
        ...
    def RemoveTarget(self, target: usdrt.Sdf._Sdf.Path) -> bool:
        ...
    def SetTargets(self, targets: list[usdrt.Sdf._Sdf.Path]) -> bool:
        ...
    def SplitName(self) -> list[str]:
        ...
    def __bool__(self) -> bool:
        ...
    def __repr__(self) -> str:
        ...
class SchemaBase:
    @staticmethod
    def GetSchemaTypeName() -> TfToken:
        ...
    def GetPrim(self) -> Prim:
        ...
    def GetPrimPath(self) -> usdrt.Sdf._Sdf.Path:
        ...
    def __bool__(self) -> bool:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Prim) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: SchemaBase) -> None:
        ...
    def __repr__(self) -> str:
        ...
class SchemaRegistry:
    @staticmethod
    def GetInstance() -> SchemaRegistry:
        ...
    def GetAliasFromName(self, name: TfToken) -> TfToken:
        ...
    def GetSchemaTypeName(self, schemaType: typing.Any) -> TfToken:
        ...
    @typing.overload
    def IsA(self, sourceType: typing.Any, queryType: typing.Any) -> bool:
        ...
    @typing.overload
    def IsA(self, sourceTypeName: TfToken, queryType: typing.Any) -> bool:
        ...
    @typing.overload
    def IsA(self, sourceType: typing.Any, queryTypeName: TfToken) -> bool:
        ...
    @typing.overload
    def IsA(self, sourceTypeName: TfToken, queryTypeName: TfToken) -> bool:
        ...
    def IsAppliedAPISchema(self, apiSchemaType: TfToken) -> bool:
        ...
    def IsConcrete(self, primType: TfToken) -> bool:
        ...
    def IsMultipleApplyAPISchema(self, apiSchemaType: TfToken) -> bool:
        ...
    def IsTyped(self, primType: TfToken) -> bool:
        ...
    def IsUnknown(self, apiSchemaType: TfToken) -> bool:
        ...
    def __bool__(self) -> bool:
        ...
    def __repr__(self: SchemaBase) -> str:
        ...
class Stage:
    class InitialLoadSet:
        """
        Members:
        
          LoadAll
        
          LoadNone
        """
        LoadAll: typing.ClassVar[Stage.InitialLoadSet]  # value = <InitialLoadSet.LoadAll: 0>
        LoadNone: typing.ClassVar[Stage.InitialLoadSet]  # value = <InitialLoadSet.LoadNone: 1>
        __members__: typing.ClassVar[dict[str, Stage.InitialLoadSet]]  # value = {'LoadAll': <InitialLoadSet.LoadAll: 0>, 'LoadNone': <InitialLoadSet.LoadNone: 1>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    class TimeChange:
        """
        Members:
        
          LazyUpdate
        
          ForceUpdate
        
          NoUpdate
        """
        ForceUpdate: typing.ClassVar[Stage.TimeChange]  # value = <TimeChange.ForceUpdate: 1>
        LazyUpdate: typing.ClassVar[Stage.TimeChange]  # value = <TimeChange.LazyUpdate: 0>
        NoUpdate: typing.ClassVar[Stage.TimeChange]  # value = <TimeChange.NoUpdate: 2>
        __members__: typing.ClassVar[dict[str, Stage.TimeChange]]  # value = {'LazyUpdate': <TimeChange.LazyUpdate: 0>, 'ForceUpdate': <TimeChange.ForceUpdate: 1>, 'NoUpdate': <TimeChange.NoUpdate: 2>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    @staticmethod
    @typing.overload
    def Attach(stageId: int) -> Stage:
        ...
    @staticmethod
    @typing.overload
    def Attach(fabricId: usdrt.helpers._helpers.FabricId) -> Stage:
        ...
    @staticmethod
    def CreateInMemory(identifier: str, load: Stage.InitialLoadSet = ...) -> Stage:
        ...
    @staticmethod
    def CreateNew(identifier: str, load: Stage.InitialLoadSet = ...) -> Stage:
        ...
    @staticmethod
    def CreateOnlyInFabric() -> Stage:
        ...
    @staticmethod
    def Open(filePath: str, load: Stage.InitialLoadSet = ...) -> Stage:
        ...
    @staticmethod
    def SimStageWithHistoryExists(stageId: int) -> bool:
        ...
    @staticmethod
    def StageWithHistoryExists(stageId: int) -> bool:
        """
        Deprecated: Use SimStageWithHistoryExists instead
        """
    def DefinePrim(self, path: usdrt.Sdf._Sdf.Path, typeName: TfToken = '') -> ...:
        ...
    def GetAttributeAtPath(self, path: usdrt.Sdf._Sdf.Path, prefetchFromUsd: bool = True) -> ...:
        ...
    def GetDefaultPrim(self, prefetchFromUsd: bool = True) -> ...:
        ...
    def GetFabricId(self) -> usdrt.helpers._helpers.FabricId:
        ...
    def GetPrimAtPath(self, path: usdrt.Sdf._Sdf.Path, prefetchFromUsd: bool = True) -> ...:
        ...
    def GetPrimsWithAppliedAPIName(self, apiName: TfToken) -> list[usdrt.Sdf._Sdf.Path]:
        ...
    def GetPrimsWithTypeAndAppliedAPIName(self, typeName: TfToken, apiNames: list[TfToken]) -> list[usdrt.Sdf._Sdf.Path]:
        ...
    def GetPrimsWithTypeName(self, typeName: TfToken) -> list[usdrt.Sdf._Sdf.Path]:
        ...
    def GetPseudoRoot(self) -> ...:
        ...
    def GetRelationshipAtPath(self, path: usdrt.Sdf._Sdf.Path, prefetchFromUsd: bool = True) -> ...:
        ...
    def GetStageExtent(self) -> usdrt.Gf._Gf.Range3d:
        ...
    def GetStageId(self) -> int:
        ...
    def GetStageIdAsStageId(self) -> usdrt.helpers._helpers.UsdStageId:
        ...
    def GetStageIdAsUInt(self) -> int:
        ...
    def GetStageInProgressId(self) -> usdrt.helpers._helpers.StageReaderWriterId:
        """
        Deprecated: Use GetStageReaderWriterId instead
        """
    def GetStageReaderWriterId(self) -> usdrt.helpers._helpers.StageReaderWriterId:
        ...
    def HasPrimAtPath(self, path: usdrt.Sdf._Sdf.Path, excludeTags: bool = True) -> bool:
        ...
    def IsFabricOnlyStage(self) -> bool:
        ...
    def RemovePrim(self, path: usdrt.Sdf._Sdf.Path) -> bool:
        ...
    def SelectPrims(self, require_prim_type: TfToken | None = None, require_applied_schemas: list[TfToken] = [], require_attrs: list[AttrSpec] = [], device: str = 'cpu', want_paths: bool = False) -> ...:
        ...
    def SetAttributeValue(self, path: usdrt.Sdf._Sdf.Path, value: typing.Any, time: TimeCode = ...) -> bool:
        ...
    def SynchronizeToFabric(self, time_change: Stage.TimeChange = ..., time: TimeCode = ...) -> None:
        ...
    def Traverse(self) -> UsdPrimRange:
        ...
    def WriteToLayer(self, filePath: str, includePrivateFabricProperties: bool = True, convertFabricXforms: bool = False) -> None:
        ...
    def WriteToStage(self, includePrivateFabricProperties: bool = True, convertFabricXforms: bool = False) -> None:
        ...
    def __repr__(self) -> str:
        ...
class TimeCode:
    __hash__: typing.ClassVar[None] = None
    @staticmethod
    def Default() -> TimeCode:
        ...
    @staticmethod
    def EarliestTime() -> TimeCode:
        ...
    def GetValue(self) -> float:
        ...
    def IsDefault(self) -> bool:
        ...
    def IsEarliestTime(self) -> bool:
        ...
    def IsNumeric(self) -> bool:
        ...
    def __eq__(self, arg0: TimeCode) -> bool:
        ...
    def __ge__(self, arg0: TimeCode) -> bool:
        ...
    def __gt__(self, arg0: TimeCode) -> bool:
        ...
    def __init__(self, t: float = 0.0) -> None:
        ...
    def __le__(self, arg0: TimeCode) -> bool:
        ...
    def __lt__(self, arg0: TimeCode) -> bool:
        ...
    def __ne__(self, arg0: TimeCode) -> bool:
        ...
    def __repr__(self) -> str:
        ...
class Tokens:
    apiSchemas: typing.ClassVar[str] = 'apiSchemas'
    clipSets: typing.ClassVar[str] = 'clipSets'
    clips: typing.ClassVar[str] = 'clips'
    collection: typing.ClassVar[str] = 'collection'
    exclude: typing.ClassVar[str] = 'exclude'
    excludes: typing.ClassVar[str] = 'excludes'
    expandPrims: typing.ClassVar[str] = 'expandPrims'
    expandPrimsAndProperties: typing.ClassVar[str] = 'expandPrimsAndProperties'
    expansionRule: typing.ClassVar[str] = 'expansionRule'
    explicitOnly: typing.ClassVar[str] = 'explicitOnly'
    fallbackPrimTypes: typing.ClassVar[str] = 'fallbackPrimTypes'
    includeRoot: typing.ClassVar[str] = 'includeRoot'
    includes: typing.ClassVar[str] = 'includes'
class Typed(SchemaBase):
    @staticmethod
    def GetSchemaTypeName() -> TfToken:
        ...
    def __bool__(self) -> bool:
        ...
    @typing.overload
    def __init__(self, arg0: Prim) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: SchemaBase) -> None:
        ...
    def __repr__(self) -> str:
        ...
class UsdCollectionMembershipQuery:
    def IsPathIncluded(self, path: usdrt.Sdf._Sdf.Path, expansionRule: TfToken = None) -> bool:
        ...
class _PrimRangeIterator:
    def GetCurrentPrim(self) -> Prim:
        """
        Since an iterator cannot be dereferenced in python, GetCurrentPrim()
         performs the same function: yielding the currently visited prim.
        """
    def IsValid(self) -> bool:
        """
        true if the iterator is not yet exhausted
        """
    def PruneChildren(self) -> None:
        ...
    def __iter__(self) -> _PrimRangeIterator:
        ...
    def __next__(self) -> Prim:
        ...
Overwrite: Access  # value = <Access.Overwrite: 3>
Read: Access  # value = <Access.Read: 1>
ReadWrite: Access  # value = <Access.ReadWrite: 2>
