from __future__ import annotations
import numpy
import pybind11_stubgen.typing_ext
import typing
import usdrt.Gf._Gf
__all__ = ['AssetArray', 'BoolArray', 'CharArray', 'DoubleArray', 'FloatArray', 'HalfArray', 'Int64Array', 'IntArray', 'Matrix3dArray', 'Matrix3fArray', 'Matrix4dArray', 'Matrix4fArray', 'QuatdArray', 'QuatfArray', 'QuathArray', 'ShortArray', 'StringArray', 'TokenArray', 'UCharArray', 'UInt64Array', 'UIntArray', 'UShortArray', 'Vec2dArray', 'Vec2fArray', 'Vec2hArray', 'Vec2iArray', 'Vec3dArray', 'Vec3fArray', 'Vec3hArray', 'Vec3iArray', 'Vec4dArray', 'Vec4fArray', 'Vec4hArray', 'Vec4iArray']
class AssetArray:
    __hash__: typing.ClassVar[None] = None
    def DetachFromSource(self) -> None:
        ...
    def HasFabricGpuData(self) -> bool:
        ...
    def IsFabricData(self) -> bool:
        ...
    def IsOwnData(self) -> bool:
        ...
    def IsPythonData(self) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: AssetArray) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Annotated[list[...], pybind11_stubgen.typing_ext.FixedSize(0)]) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Any) -> bool:
        ...
    def __getitem__(self, arg0: int) -> ...:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Any) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[numpy.uint64]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[...]) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: int, arg1: ...) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def __array_interface__(self) -> dict:
        ...
    @property
    def __cuda_array_interface__(self) -> dict:
        ...
class BoolArray:
    __hash__: typing.ClassVar[None] = None
    def DetachFromSource(self) -> None:
        ...
    def HasFabricGpuData(self) -> bool:
        ...
    def IsFabricData(self) -> bool:
        ...
    def IsOwnData(self) -> bool:
        ...
    def IsPythonData(self) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: BoolArray) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Annotated[list[bool], pybind11_stubgen.typing_ext.FixedSize(0)]) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Any) -> bool:
        ...
    def __getitem__(self, arg0: int) -> bool:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Any) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[bool]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[bool]) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: int, arg1: bool) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def __array_interface__(self) -> dict:
        ...
    @property
    def __cuda_array_interface__(self) -> dict:
        ...
class CharArray:
    __hash__: typing.ClassVar[None] = None
    def DetachFromSource(self) -> None:
        ...
    def HasFabricGpuData(self) -> bool:
        ...
    def IsFabricData(self) -> bool:
        ...
    def IsOwnData(self) -> bool:
        ...
    def IsPythonData(self) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: CharArray) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Annotated[list[str], pybind11_stubgen.typing_ext.FixedSize(0)]) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Any) -> bool:
        ...
    def __getitem__(self, arg0: int) -> str:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Any) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[numpy.int8]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[str]) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: int, arg1: str) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def __array_interface__(self) -> dict:
        ...
    @property
    def __cuda_array_interface__(self) -> dict:
        ...
class DoubleArray:
    __hash__: typing.ClassVar[None] = None
    def DetachFromSource(self) -> None:
        ...
    def HasFabricGpuData(self) -> bool:
        ...
    def IsFabricData(self) -> bool:
        ...
    def IsOwnData(self) -> bool:
        ...
    def IsPythonData(self) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: DoubleArray) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(0)]) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Any) -> bool:
        ...
    def __getitem__(self, arg0: int) -> float:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Any) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[numpy.float64]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[float]) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: int, arg1: float) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def __array_interface__(self) -> dict:
        ...
    @property
    def __cuda_array_interface__(self) -> dict:
        ...
class FloatArray:
    __hash__: typing.ClassVar[None] = None
    def DetachFromSource(self) -> None:
        ...
    def HasFabricGpuData(self) -> bool:
        ...
    def IsFabricData(self) -> bool:
        ...
    def IsOwnData(self) -> bool:
        ...
    def IsPythonData(self) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: FloatArray) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(0)]) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Any) -> bool:
        ...
    def __getitem__(self, arg0: int) -> float:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Any) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[numpy.float32]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[float]) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: int, arg1: float) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def __array_interface__(self) -> dict:
        ...
    @property
    def __cuda_array_interface__(self) -> dict:
        ...
class HalfArray:
    __hash__: typing.ClassVar[None] = None
    def DetachFromSource(self) -> None:
        ...
    def HasFabricGpuData(self) -> bool:
        ...
    def IsFabricData(self) -> bool:
        ...
    def IsOwnData(self) -> bool:
        ...
    def IsPythonData(self) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: HalfArray) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Annotated[list[GfHalf], pybind11_stubgen.typing_ext.FixedSize(0)]) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Any) -> bool:
        ...
    def __getitem__(self, arg0: int) -> GfHalf:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Any) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[float16]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[GfHalf]) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: int, arg1: GfHalf) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def __array_interface__(self) -> dict:
        ...
    @property
    def __cuda_array_interface__(self) -> dict:
        ...
class Int64Array:
    __hash__: typing.ClassVar[None] = None
    def DetachFromSource(self) -> None:
        ...
    def HasFabricGpuData(self) -> bool:
        ...
    def IsFabricData(self) -> bool:
        ...
    def IsOwnData(self) -> bool:
        ...
    def IsPythonData(self) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: Int64Array) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(0)]) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Any) -> bool:
        ...
    def __getitem__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Any) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[numpy.int64]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[int]) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: int, arg1: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def __array_interface__(self) -> dict:
        ...
    @property
    def __cuda_array_interface__(self) -> dict:
        ...
class IntArray:
    __hash__: typing.ClassVar[None] = None
    def DetachFromSource(self) -> None:
        ...
    def HasFabricGpuData(self) -> bool:
        ...
    def IsFabricData(self) -> bool:
        ...
    def IsOwnData(self) -> bool:
        ...
    def IsPythonData(self) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: IntArray) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(0)]) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Any) -> bool:
        ...
    def __getitem__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Any) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[numpy.int32]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[int]) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: int, arg1: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def __array_interface__(self) -> dict:
        ...
    @property
    def __cuda_array_interface__(self) -> dict:
        ...
class Matrix3dArray:
    __hash__: typing.ClassVar[None] = None
    def DetachFromSource(self) -> None:
        ...
    def HasFabricGpuData(self) -> bool:
        ...
    def IsFabricData(self) -> bool:
        ...
    def IsOwnData(self) -> bool:
        ...
    def IsPythonData(self) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: Matrix3dArray) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Annotated[list[usdrt.Gf._Gf.Matrix3d], pybind11_stubgen.typing_ext.FixedSize(0)]) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Any) -> bool:
        ...
    def __getitem__(self, arg0: int) -> usdrt.Gf._Gf.Matrix3d:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Any) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[numpy.float64]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[usdrt.Gf._Gf.Matrix3d]) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: int, arg1: usdrt.Gf._Gf.Matrix3d) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def __array_interface__(self) -> dict:
        ...
    @property
    def __cuda_array_interface__(self) -> dict:
        ...
class Matrix3fArray:
    __hash__: typing.ClassVar[None] = None
    def DetachFromSource(self) -> None:
        ...
    def HasFabricGpuData(self) -> bool:
        ...
    def IsFabricData(self) -> bool:
        ...
    def IsOwnData(self) -> bool:
        ...
    def IsPythonData(self) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: Matrix3fArray) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Annotated[list[usdrt.Gf._Gf.Matrix3f], pybind11_stubgen.typing_ext.FixedSize(0)]) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Any) -> bool:
        ...
    def __getitem__(self, arg0: int) -> usdrt.Gf._Gf.Matrix3f:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Any) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[numpy.float32]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[usdrt.Gf._Gf.Matrix3f]) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: int, arg1: usdrt.Gf._Gf.Matrix3f) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def __array_interface__(self) -> dict:
        ...
    @property
    def __cuda_array_interface__(self) -> dict:
        ...
class Matrix4dArray:
    __hash__: typing.ClassVar[None] = None
    def DetachFromSource(self) -> None:
        ...
    def HasFabricGpuData(self) -> bool:
        ...
    def IsFabricData(self) -> bool:
        ...
    def IsOwnData(self) -> bool:
        ...
    def IsPythonData(self) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: Matrix4dArray) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Annotated[list[usdrt.Gf._Gf.Matrix4d], pybind11_stubgen.typing_ext.FixedSize(0)]) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Any) -> bool:
        ...
    def __getitem__(self, arg0: int) -> usdrt.Gf._Gf.Matrix4d:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Any) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[numpy.float64]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[usdrt.Gf._Gf.Matrix4d]) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: int, arg1: usdrt.Gf._Gf.Matrix4d) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def __array_interface__(self) -> dict:
        ...
    @property
    def __cuda_array_interface__(self) -> dict:
        ...
class Matrix4fArray:
    __hash__: typing.ClassVar[None] = None
    def DetachFromSource(self) -> None:
        ...
    def HasFabricGpuData(self) -> bool:
        ...
    def IsFabricData(self) -> bool:
        ...
    def IsOwnData(self) -> bool:
        ...
    def IsPythonData(self) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: Matrix4fArray) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Annotated[list[usdrt.Gf._Gf.Matrix4f], pybind11_stubgen.typing_ext.FixedSize(0)]) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Any) -> bool:
        ...
    def __getitem__(self, arg0: int) -> usdrt.Gf._Gf.Matrix4f:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Any) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[numpy.float32]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[usdrt.Gf._Gf.Matrix4f]) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: int, arg1: usdrt.Gf._Gf.Matrix4f) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def __array_interface__(self) -> dict:
        ...
    @property
    def __cuda_array_interface__(self) -> dict:
        ...
class QuatdArray:
    __hash__: typing.ClassVar[None] = None
    def DetachFromSource(self) -> None:
        ...
    def HasFabricGpuData(self) -> bool:
        ...
    def IsFabricData(self) -> bool:
        ...
    def IsOwnData(self) -> bool:
        ...
    def IsPythonData(self) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: QuatdArray) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Annotated[list[usdrt.Gf._Gf.Quatd], pybind11_stubgen.typing_ext.FixedSize(0)]) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Any) -> bool:
        ...
    def __getitem__(self, arg0: int) -> usdrt.Gf._Gf.Quatd:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Any) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[numpy.float64]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[usdrt.Gf._Gf.Quatd]) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: int, arg1: usdrt.Gf._Gf.Quatd) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def __array_interface__(self) -> dict:
        ...
    @property
    def __cuda_array_interface__(self) -> dict:
        ...
class QuatfArray:
    __hash__: typing.ClassVar[None] = None
    def DetachFromSource(self) -> None:
        ...
    def HasFabricGpuData(self) -> bool:
        ...
    def IsFabricData(self) -> bool:
        ...
    def IsOwnData(self) -> bool:
        ...
    def IsPythonData(self) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: QuatfArray) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Annotated[list[usdrt.Gf._Gf.Quatf], pybind11_stubgen.typing_ext.FixedSize(0)]) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Any) -> bool:
        ...
    def __getitem__(self, arg0: int) -> usdrt.Gf._Gf.Quatf:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Any) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[numpy.float32]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[usdrt.Gf._Gf.Quatf]) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: int, arg1: usdrt.Gf._Gf.Quatf) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def __array_interface__(self) -> dict:
        ...
    @property
    def __cuda_array_interface__(self) -> dict:
        ...
class QuathArray:
    __hash__: typing.ClassVar[None] = None
    def DetachFromSource(self) -> None:
        ...
    def HasFabricGpuData(self) -> bool:
        ...
    def IsFabricData(self) -> bool:
        ...
    def IsOwnData(self) -> bool:
        ...
    def IsPythonData(self) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: QuathArray) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Annotated[list[usdrt.Gf._Gf.Quath], pybind11_stubgen.typing_ext.FixedSize(0)]) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Any) -> bool:
        ...
    def __getitem__(self, arg0: int) -> usdrt.Gf._Gf.Quath:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Any) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[float16]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[usdrt.Gf._Gf.Quath]) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: int, arg1: usdrt.Gf._Gf.Quath) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def __array_interface__(self) -> dict:
        ...
    @property
    def __cuda_array_interface__(self) -> dict:
        ...
class ShortArray:
    __hash__: typing.ClassVar[None] = None
    def DetachFromSource(self) -> None:
        ...
    def HasFabricGpuData(self) -> bool:
        ...
    def IsFabricData(self) -> bool:
        ...
    def IsOwnData(self) -> bool:
        ...
    def IsPythonData(self) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: ShortArray) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(0)]) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Any) -> bool:
        ...
    def __getitem__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Any) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[numpy.int16]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[int]) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: int, arg1: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def __array_interface__(self) -> dict:
        ...
    @property
    def __cuda_array_interface__(self) -> dict:
        ...
class StringArray:
    __hash__: typing.ClassVar[None] = None
    def DetachFromSource(self) -> None:
        ...
    def HasFabricGpuData(self) -> bool:
        ...
    def IsFabricData(self) -> bool:
        ...
    def IsOwnData(self) -> bool:
        ...
    def IsPythonData(self) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: StringArray) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Annotated[list[str], pybind11_stubgen.typing_ext.FixedSize(0)]) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Any) -> bool:
        ...
    def __getitem__(self, arg0: int) -> str:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Any) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[numpy.int8]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[str]) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: int, arg1: str) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def __array_interface__(self) -> dict:
        ...
    @property
    def __cuda_array_interface__(self) -> dict:
        ...
class TokenArray:
    __hash__: typing.ClassVar[None] = None
    def DetachFromSource(self) -> None:
        ...
    def HasFabricGpuData(self) -> bool:
        ...
    def IsFabricData(self) -> bool:
        ...
    def IsOwnData(self) -> bool:
        ...
    def IsPythonData(self) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: TokenArray) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Annotated[list[TfToken], pybind11_stubgen.typing_ext.FixedSize(0)]) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Any) -> bool:
        ...
    def __getitem__(self, arg0: int) -> TfToken:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Any) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[numpy.uint64]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[TfToken]) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: int, arg1: TfToken) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def __array_interface__(self) -> dict:
        ...
    @property
    def __cuda_array_interface__(self) -> dict:
        ...
class UCharArray:
    __hash__: typing.ClassVar[None] = None
    def DetachFromSource(self) -> None:
        ...
    def HasFabricGpuData(self) -> bool:
        ...
    def IsFabricData(self) -> bool:
        ...
    def IsOwnData(self) -> bool:
        ...
    def IsPythonData(self) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: UCharArray) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(0)]) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Any) -> bool:
        ...
    def __getitem__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Any) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[numpy.uint8]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[int]) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: int, arg1: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def __array_interface__(self) -> dict:
        ...
    @property
    def __cuda_array_interface__(self) -> dict:
        ...
class UInt64Array:
    __hash__: typing.ClassVar[None] = None
    def DetachFromSource(self) -> None:
        ...
    def HasFabricGpuData(self) -> bool:
        ...
    def IsFabricData(self) -> bool:
        ...
    def IsOwnData(self) -> bool:
        ...
    def IsPythonData(self) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: UInt64Array) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(0)]) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Any) -> bool:
        ...
    def __getitem__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Any) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[numpy.uint64]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[int]) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: int, arg1: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def __array_interface__(self) -> dict:
        ...
    @property
    def __cuda_array_interface__(self) -> dict:
        ...
class UIntArray:
    __hash__: typing.ClassVar[None] = None
    def DetachFromSource(self) -> None:
        ...
    def HasFabricGpuData(self) -> bool:
        ...
    def IsFabricData(self) -> bool:
        ...
    def IsOwnData(self) -> bool:
        ...
    def IsPythonData(self) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: UIntArray) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(0)]) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Any) -> bool:
        ...
    def __getitem__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Any) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[numpy.uint32]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[int]) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: int, arg1: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def __array_interface__(self) -> dict:
        ...
    @property
    def __cuda_array_interface__(self) -> dict:
        ...
class UShortArray:
    __hash__: typing.ClassVar[None] = None
    def DetachFromSource(self) -> None:
        ...
    def HasFabricGpuData(self) -> bool:
        ...
    def IsFabricData(self) -> bool:
        ...
    def IsOwnData(self) -> bool:
        ...
    def IsPythonData(self) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: UShortArray) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(0)]) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Any) -> bool:
        ...
    def __getitem__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Any) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[numpy.uint16]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[int]) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: int, arg1: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def __array_interface__(self) -> dict:
        ...
    @property
    def __cuda_array_interface__(self) -> dict:
        ...
class Vec2dArray:
    __hash__: typing.ClassVar[None] = None
    def DetachFromSource(self) -> None:
        ...
    def HasFabricGpuData(self) -> bool:
        ...
    def IsFabricData(self) -> bool:
        ...
    def IsOwnData(self) -> bool:
        ...
    def IsPythonData(self) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: Vec2dArray) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Annotated[list[usdrt.Gf._Gf.Vec2d], pybind11_stubgen.typing_ext.FixedSize(0)]) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Any) -> bool:
        ...
    def __getitem__(self, arg0: int) -> usdrt.Gf._Gf.Vec2d:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Any) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[numpy.float64]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[usdrt.Gf._Gf.Vec2d]) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: int, arg1: usdrt.Gf._Gf.Vec2d) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def __array_interface__(self) -> dict:
        ...
    @property
    def __cuda_array_interface__(self) -> dict:
        ...
class Vec2fArray:
    __hash__: typing.ClassVar[None] = None
    def DetachFromSource(self) -> None:
        ...
    def HasFabricGpuData(self) -> bool:
        ...
    def IsFabricData(self) -> bool:
        ...
    def IsOwnData(self) -> bool:
        ...
    def IsPythonData(self) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: Vec2fArray) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Annotated[list[usdrt.Gf._Gf.Vec2f], pybind11_stubgen.typing_ext.FixedSize(0)]) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Any) -> bool:
        ...
    def __getitem__(self, arg0: int) -> usdrt.Gf._Gf.Vec2f:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Any) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[numpy.float32]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[usdrt.Gf._Gf.Vec2f]) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: int, arg1: usdrt.Gf._Gf.Vec2f) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def __array_interface__(self) -> dict:
        ...
    @property
    def __cuda_array_interface__(self) -> dict:
        ...
class Vec2hArray:
    __hash__: typing.ClassVar[None] = None
    def DetachFromSource(self) -> None:
        ...
    def HasFabricGpuData(self) -> bool:
        ...
    def IsFabricData(self) -> bool:
        ...
    def IsOwnData(self) -> bool:
        ...
    def IsPythonData(self) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: Vec2hArray) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Annotated[list[usdrt.Gf._Gf.Vec2h], pybind11_stubgen.typing_ext.FixedSize(0)]) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Any) -> bool:
        ...
    def __getitem__(self, arg0: int) -> usdrt.Gf._Gf.Vec2h:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Any) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[float16]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[usdrt.Gf._Gf.Vec2h]) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: int, arg1: usdrt.Gf._Gf.Vec2h) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def __array_interface__(self) -> dict:
        ...
    @property
    def __cuda_array_interface__(self) -> dict:
        ...
class Vec2iArray:
    __hash__: typing.ClassVar[None] = None
    def DetachFromSource(self) -> None:
        ...
    def HasFabricGpuData(self) -> bool:
        ...
    def IsFabricData(self) -> bool:
        ...
    def IsOwnData(self) -> bool:
        ...
    def IsPythonData(self) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: Vec2iArray) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Annotated[list[usdrt.Gf._Gf.Vec2i], pybind11_stubgen.typing_ext.FixedSize(0)]) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Any) -> bool:
        ...
    def __getitem__(self, arg0: int) -> usdrt.Gf._Gf.Vec2i:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Any) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[numpy.int32]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[usdrt.Gf._Gf.Vec2i]) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: int, arg1: usdrt.Gf._Gf.Vec2i) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def __array_interface__(self) -> dict:
        ...
    @property
    def __cuda_array_interface__(self) -> dict:
        ...
class Vec3dArray:
    __hash__: typing.ClassVar[None] = None
    def DetachFromSource(self) -> None:
        ...
    def HasFabricGpuData(self) -> bool:
        ...
    def IsFabricData(self) -> bool:
        ...
    def IsOwnData(self) -> bool:
        ...
    def IsPythonData(self) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: Vec3dArray) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Annotated[list[usdrt.Gf._Gf.Vec3d], pybind11_stubgen.typing_ext.FixedSize(0)]) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Any) -> bool:
        ...
    def __getitem__(self, arg0: int) -> usdrt.Gf._Gf.Vec3d:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Any) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[numpy.float64]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[usdrt.Gf._Gf.Vec3d]) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: int, arg1: usdrt.Gf._Gf.Vec3d) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def __array_interface__(self) -> dict:
        ...
    @property
    def __cuda_array_interface__(self) -> dict:
        ...
class Vec3fArray:
    __hash__: typing.ClassVar[None] = None
    def DetachFromSource(self) -> None:
        ...
    def HasFabricGpuData(self) -> bool:
        ...
    def IsFabricData(self) -> bool:
        ...
    def IsOwnData(self) -> bool:
        ...
    def IsPythonData(self) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: Vec3fArray) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Annotated[list[usdrt.Gf._Gf.Vec3f], pybind11_stubgen.typing_ext.FixedSize(0)]) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Any) -> bool:
        ...
    def __getitem__(self, arg0: int) -> usdrt.Gf._Gf.Vec3f:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Any) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[numpy.float32]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[usdrt.Gf._Gf.Vec3f]) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: int, arg1: usdrt.Gf._Gf.Vec3f) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def __array_interface__(self) -> dict:
        ...
    @property
    def __cuda_array_interface__(self) -> dict:
        ...
class Vec3hArray:
    __hash__: typing.ClassVar[None] = None
    def DetachFromSource(self) -> None:
        ...
    def HasFabricGpuData(self) -> bool:
        ...
    def IsFabricData(self) -> bool:
        ...
    def IsOwnData(self) -> bool:
        ...
    def IsPythonData(self) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: Vec3hArray) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Annotated[list[usdrt.Gf._Gf.Vec3h], pybind11_stubgen.typing_ext.FixedSize(0)]) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Any) -> bool:
        ...
    def __getitem__(self, arg0: int) -> usdrt.Gf._Gf.Vec3h:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Any) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[float16]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[usdrt.Gf._Gf.Vec3h]) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: int, arg1: usdrt.Gf._Gf.Vec3h) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def __array_interface__(self) -> dict:
        ...
    @property
    def __cuda_array_interface__(self) -> dict:
        ...
class Vec3iArray:
    __hash__: typing.ClassVar[None] = None
    def DetachFromSource(self) -> None:
        ...
    def HasFabricGpuData(self) -> bool:
        ...
    def IsFabricData(self) -> bool:
        ...
    def IsOwnData(self) -> bool:
        ...
    def IsPythonData(self) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: Vec3iArray) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Annotated[list[usdrt.Gf._Gf.Vec3i], pybind11_stubgen.typing_ext.FixedSize(0)]) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Any) -> bool:
        ...
    def __getitem__(self, arg0: int) -> usdrt.Gf._Gf.Vec3i:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Any) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[numpy.int32]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[usdrt.Gf._Gf.Vec3i]) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: int, arg1: usdrt.Gf._Gf.Vec3i) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def __array_interface__(self) -> dict:
        ...
    @property
    def __cuda_array_interface__(self) -> dict:
        ...
class Vec4dArray:
    __hash__: typing.ClassVar[None] = None
    def DetachFromSource(self) -> None:
        ...
    def HasFabricGpuData(self) -> bool:
        ...
    def IsFabricData(self) -> bool:
        ...
    def IsOwnData(self) -> bool:
        ...
    def IsPythonData(self) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: Vec4dArray) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Annotated[list[usdrt.Gf._Gf.Vec4d], pybind11_stubgen.typing_ext.FixedSize(0)]) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Any) -> bool:
        ...
    def __getitem__(self, arg0: int) -> usdrt.Gf._Gf.Vec4d:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Any) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[numpy.float64]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[usdrt.Gf._Gf.Vec4d]) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: int, arg1: usdrt.Gf._Gf.Vec4d) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def __array_interface__(self) -> dict:
        ...
    @property
    def __cuda_array_interface__(self) -> dict:
        ...
class Vec4fArray:
    __hash__: typing.ClassVar[None] = None
    def DetachFromSource(self) -> None:
        ...
    def HasFabricGpuData(self) -> bool:
        ...
    def IsFabricData(self) -> bool:
        ...
    def IsOwnData(self) -> bool:
        ...
    def IsPythonData(self) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: Vec4fArray) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Annotated[list[usdrt.Gf._Gf.Vec4f], pybind11_stubgen.typing_ext.FixedSize(0)]) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Any) -> bool:
        ...
    def __getitem__(self, arg0: int) -> usdrt.Gf._Gf.Vec4f:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Any) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[numpy.float32]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[usdrt.Gf._Gf.Vec4f]) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: int, arg1: usdrt.Gf._Gf.Vec4f) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def __array_interface__(self) -> dict:
        ...
    @property
    def __cuda_array_interface__(self) -> dict:
        ...
class Vec4hArray:
    __hash__: typing.ClassVar[None] = None
    def DetachFromSource(self) -> None:
        ...
    def HasFabricGpuData(self) -> bool:
        ...
    def IsFabricData(self) -> bool:
        ...
    def IsOwnData(self) -> bool:
        ...
    def IsPythonData(self) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: Vec4hArray) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Annotated[list[usdrt.Gf._Gf.Vec4h], pybind11_stubgen.typing_ext.FixedSize(0)]) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Any) -> bool:
        ...
    def __getitem__(self, arg0: int) -> usdrt.Gf._Gf.Vec4h:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Any) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[float16]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[usdrt.Gf._Gf.Vec4h]) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: int, arg1: usdrt.Gf._Gf.Vec4h) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def __array_interface__(self) -> dict:
        ...
    @property
    def __cuda_array_interface__(self) -> dict:
        ...
class Vec4iArray:
    __hash__: typing.ClassVar[None] = None
    def DetachFromSource(self) -> None:
        ...
    def HasFabricGpuData(self) -> bool:
        ...
    def IsFabricData(self) -> bool:
        ...
    def IsOwnData(self) -> bool:
        ...
    def IsPythonData(self) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: Vec4iArray) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Annotated[list[usdrt.Gf._Gf.Vec4i], pybind11_stubgen.typing_ext.FixedSize(0)]) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: typing.Any) -> bool:
        ...
    def __getitem__(self, arg0: int) -> usdrt.Gf._Gf.Vec4i:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Any) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[numpy.int32]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[usdrt.Gf._Gf.Vec4i]) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: int, arg1: usdrt.Gf._Gf.Vec4i) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def __array_interface__(self) -> dict:
        ...
    @property
    def __cuda_array_interface__(self) -> dict:
        ...
