from __future__ import annotations
import typing
import typing_extensions
__all__ = ['Abs', 'Absf', 'BBox3d', 'Clamp', 'Clampf', 'CompDiv', 'CompMult', 'Cross', 'DegreesToRadians', 'Dot', 'FindClosestPoints', 'FitPlaneToPoints', 'Frustum', 'GetComplement', 'GetLength', 'GetNormalized', 'GetProjection', 'IsClose', 'Lerp', 'Lerpf', 'Line', 'LineSeg', 'Matrix2d', 'Matrix2f', 'Matrix3d', 'Matrix3f', 'Matrix4d', 'Matrix4f', 'Max', 'Min', 'Normalize', 'Plane', 'Quatd', 'Quatf', 'Quath', 'RadiansToDegrees', 'Range1d', 'Range1f', 'Range2d', 'Range2f', 'Range3d', 'Range3f', 'Ray', 'Rect2i', 'Rotation', 'Slerp', 'Sqr', 'Sqrt', 'Transform', 'Vec2d', 'Vec2f', 'Vec2h', 'Vec2i', 'Vec3d', 'Vec3f', 'Vec3h', 'Vec3i', 'Vec4d', 'Vec4f', 'Vec4h', 'Vec4i']
class BBox3d:
    """
    Arbitrarily oriented 3D bounding box
    """
    __hash__: typing.ClassVar[None] = None
    box: Range3d
    hasZeroAreaPrimitives: bool
    matrix: Matrix4d
    @staticmethod
    def Combine(b1: BBox3d, b2: BBox3d) -> BBox3d:
        ...
    def ComputeAlignedBox(self) -> Range3d:
        ...
    def ComputeAlignedRange(self) -> Range3d:
        ...
    def ComputeCentroid(self) -> Vec3d:
        ...
    def GetBox(self) -> Range3d:
        ...
    def GetInverseMatrix(self) -> Matrix4d:
        ...
    def GetMatrix(self) -> Matrix4d:
        ...
    def GetRange(self) -> Range3d:
        ...
    def GetVolume(self) -> float:
        ...
    def HasZeroAreaPrimitives(self) -> bool:
        ...
    def Set(self, range: Range3d, mat: Matrix4d) -> BBox3d:
        ...
    def SetHasZeroAreaPrimitives(self, hasThem: bool) -> None:
        ...
    def SetMatrix(self, mat: Matrix4d) -> BBox3d:
        ...
    def SetRange(self, range: Range3d) -> BBox3d:
        ...
    def Transform(self, transform: Matrix4d) -> BBox3d:
        ...
    def __eq__(self, arg0: BBox3d) -> bool:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: BBox3d) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Range3d) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Range3d, arg1: Matrix4d) -> None:
        ...
    def __ne__(self, arg0: BBox3d) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
class Frustum:
    """
    Basic view frustum
    """
    class ProjectionType:
        """
        Members:
        
          Orthographic
        
          Perspective
        """
        Orthographic: typing.ClassVar[Frustum.ProjectionType]  # value = <ProjectionType.Orthographic: 0>
        Perspective: typing.ClassVar[Frustum.ProjectionType]  # value = <ProjectionType.Perspective: 1>
        __members__: typing.ClassVar[dict[str, Frustum.ProjectionType]]  # value = {'Orthographic': <ProjectionType.Orthographic: 0>, 'Perspective': <ProjectionType.Perspective: 1>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    Orthographic: typing.ClassVar[Frustum.ProjectionType]  # value = <ProjectionType.Orthographic: 0>
    Perspective: typing.ClassVar[Frustum.ProjectionType]  # value = <ProjectionType.Perspective: 1>
    __hash__: typing.ClassVar[None] = None
    nearFar: Range1d
    position: Vec3d
    projectionType: ...
    rotation: Rotation
    viewDistance: float
    window: Range2d
    @staticmethod
    def GetReferencePlaneDepth() -> float:
        ...
    @staticmethod
    def IntersectsViewVolume(bbox: ..., vpMat: Matrix4d) -> bool:
        ...
    def ComputeAspectRatio(self) -> float:
        ...
    def ComputeCorners(self) -> list[Vec3d]:
        ...
    def ComputeCornersAtDistance(self, distance: float) -> list[Vec3d]:
        ...
    def ComputeLookAtPoint(self) -> Vec3d:
        ...
    @typing.overload
    def ComputeNarrowedFrustum(self, point: Vec2d, halfSize: Vec2d) -> Frustum:
        ...
    @typing.overload
    def ComputeNarrowedFrustum(self, worldPoint: Vec3d, halfSize: Vec2d) -> Frustum:
        ...
    @typing.overload
    def ComputePickRay(self, windowPos: Vec2d) -> Ray:
        ...
    @typing.overload
    def ComputePickRay(self, worldSpacePos: Vec3d) -> Ray:
        ...
    def ComputeProjectionMatrix(self) -> Matrix4d:
        ...
    def ComputeUpVector(self) -> Vec3d:
        ...
    def ComputeViewDirection(self) -> Vec3d:
        ...
    def ComputeViewFrame(self) -> tuple:
        ...
    def ComputeViewInverse(self) -> Matrix4d:
        ...
    def ComputeViewMatrix(self) -> Matrix4d:
        ...
    def FitToSphere(self, center: Vec3d, radius: float, slack: float = 0.0) -> None:
        ...
    def GetFOV(self, isFovVertical: bool = False) -> float:
        """
        Returns the horizontal fov of the frustum. The fov of the
        frustum is not necessarily the same value as displayed in
        the viewer. The displayed fov is a function of the focal
        length or FOV avar. The frustum's fov may be different due
        to things like lens breathing.
        
        If the frustum is not of type GfFrustum::Perspective, the
        returned FOV will be 0.0.
        """
    def GetNearFar(self) -> Range1d:
        ...
    def GetOrthographic(self) -> tuple:
        ...
    def GetPerspective(self, isFovVertical: bool = True) -> typing.Any:
        """
        Returns the current perspective frustum values suitable
        for use by SetPerspective.  If the current frustum is a
        perspective projection, the return value is a tuple of
        fieldOfView, aspectRatio, nearDistance, farDistance).
        If the current frustum is not perspective, the return
        value is None.
        """
    def GetPosition(self) -> Vec3d:
        ...
    def GetProjectionType(self) -> ...:
        ...
    def GetRotation(self) -> Rotation:
        ...
    def GetViewDistance(self) -> float:
        ...
    def GetWindow(self) -> Range2d:
        ...
    @typing.overload
    def Intersects(self, bbox: ...) -> bool:
        ...
    @typing.overload
    def Intersects(self, point: Vec3d) -> bool:
        ...
    @typing.overload
    def Intersects(self, p0: Vec3d, p1: Vec3d) -> bool:
        ...
    @typing.overload
    def Intersects(self, p0: Vec3d, p1: Vec3d, p2: Vec3d) -> bool:
        ...
    def SetNearFar(self, nearFar: Range1d) -> None:
        ...
    def SetOrthographic(self, left: float, right: float, bottom: float, top: float, nearPlane: float, farPlane: float) -> None:
        ...
    @typing.overload
    def SetPerspective(self, fovHeight: float, aspectRatio: float, nearDist: float, farDist: float) -> None:
        ...
    @typing.overload
    def SetPerspective(self, fov: float, isFovVertical: bool, aspectRatio: float, nearDist: float, farDist: float) -> None:
        ...
    def SetPosition(self, position: Vec3d) -> None:
        ...
    def SetPositionAndRotationFromMatrix(self, camToWorldXf: Matrix4d) -> None:
        ...
    def SetProjectionType(self, projectionType: ...) -> None:
        ...
    def SetRotation(self, rotation: Rotation) -> None:
        ...
    def SetViewDistance(self, viewDistance: float) -> None:
        ...
    def SetWindow(self, window: Range2d) -> None:
        ...
    def Transform(self, matrix: Matrix4d) -> Frustum:
        ...
    def __eq__(self, arg0: Frustum) -> bool:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Frustum) -> None:
        ...
    @typing.overload
    def __init__(self, position: Vec3d, rotation: Rotation, window: Range2d, nearFar: Range1d, projectionType: ..., viewDistance: float = 5.0) -> None:
        ...
    @typing.overload
    def __init__(self, camToWorldXf: Matrix4d, window: Range2d, nearFar: Range1d, projectionType: ..., viewDistance: float = 5.0) -> None:
        ...
    def __ne__(self, arg0: Frustum) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
class Line:
    """
    Line class
    """
    __hash__: typing.ClassVar[None] = None
    direction: Vec3d
    def FindClosestPoint(self, point: Vec3d) -> tuple:
        ...
    def GetDirection(self) -> Vec3d:
        ...
    def GetPoint(self, t: float) -> Vec3d:
        ...
    def Set(self, p0: Vec3d, dir: Vec3d) -> Line:
        ...
    def __eq__(self, arg0: Line) -> bool:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, p0: Vec3d, dir: Vec3d) -> None:
        ...
    def __ne__(self, arg0: Line) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
class LineSeg:
    """
    Line segment class
    """
    __hash__: typing.ClassVar[None] = None
    def FindClosestPoint(self, point: Vec3d) -> tuple:
        ...
    def GetDirection(self) -> Vec3d:
        ...
    def GetLength(self) -> float:
        ...
    def GetPoint(self, t: float) -> Vec3d:
        ...
    def __eq__(self, arg0: LineSeg) -> bool:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, p0: Vec3d, p1: Vec3d) -> None:
        ...
    def __ne__(self, arg0: LineSeg) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    @property
    def direction(self) -> Vec3d:
        ...
    @property
    def length(self) -> float:
        ...
class Matrix2d:
    __hash__: typing.ClassVar[None] = None
    dimension: typing.ClassVar[tuple] = (2, 2)
    def GetArrayItem(self, arg0: int) -> float:
        ...
    def GetColumn(self, arg0: int) -> Vec2d:
        ...
    def GetDeterminant(self) -> float:
        ...
    def GetInverse(self) -> Matrix2d:
        ...
    def GetRow(self, arg0: int) -> Vec2d:
        ...
    def GetTranspose(self) -> Matrix2d:
        ...
    def Set(self, arg0: float, arg1: float, arg2: float, arg3: float) -> Matrix2d:
        ...
    def SetArrayItem(self, arg0: int, arg1: float) -> None:
        ...
    def SetColumn(self, arg0: int, arg1: Vec2d) -> None:
        ...
    @typing.overload
    def SetDiagonal(self, arg0: float) -> Matrix2d:
        ...
    @typing.overload
    def SetDiagonal(self, arg0: Vec2d) -> Matrix2d:
        ...
    def SetIdentity(self) -> Matrix2d:
        ...
    def SetRow(self, arg0: int, arg1: Vec2d) -> None:
        ...
    def SetZero(self) -> Matrix2d:
        ...
    def __add__(self, arg0: Matrix2d) -> Matrix2d:
        ...
    def __contains__(self, arg0: float) -> bool:
        ...
    def __copy__(self) -> Matrix2d:
        ...
    def __deepcopy__(self, memo: dict) -> Matrix2d:
        ...
    @typing.overload
    def __eq__(self, arg0: Matrix2d) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: ...) -> bool:
        ...
    @typing.overload
    def __getitem__(self, arg0: tuple) -> float:
        ...
    @typing.overload
    def __getitem__(self, arg0: int) -> Vec2d:
        ...
    @typing.overload
    def __getitem__(self, arg0: int) -> Vec2d:
        ...
    def __iadd__(self, arg0: Matrix2d) -> Matrix2d:
        ...
    def __imul__(self, arg0: float) -> Matrix2d:
        ...
    @typing.overload
    def __init__(self, arg0: Matrix2d) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: ...) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing_extensions.Buffer) -> None:
        ...
    def __isub__(self, arg0: Matrix2d) -> Matrix2d:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> Matrix2d:
        ...
    @typing.overload
    def __mul__(self, arg0: Matrix2d) -> Matrix2d:
        ...
    @typing.overload
    def __mul__(self, arg0: Vec2d) -> Vec2d:
        ...
    @typing.overload
    def __mul__(self, arg0: Vec2f) -> Vec2f:
        ...
    @typing.overload
    def __ne__(self, arg0: Matrix2d) -> bool:
        ...
    @typing.overload
    def __ne__(self, arg0: ...) -> bool:
        ...
    def __neg__(self) -> Matrix2d:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> Matrix2d:
        ...
    @typing.overload
    def __rmul__(self, arg0: Vec2d) -> Vec2d:
        ...
    @typing.overload
    def __rmul__(self, arg0: Vec2f) -> Vec2f:
        ...
    @typing.overload
    def __setitem__(self, arg0: tuple, arg1: float) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: Vec2d) -> None:
        ...
    def __str__(self) -> str:
        ...
    def __sub__(self, arg0: Matrix2d) -> Matrix2d:
        ...
    def __truediv__(self, arg0: Matrix2d) -> Matrix2d:
        ...
class Matrix2f:
    __hash__: typing.ClassVar[None] = None
    dimension: typing.ClassVar[tuple] = (2, 2)
    def GetArrayItem(self, arg0: int) -> float:
        ...
    def GetColumn(self, arg0: int) -> Vec2f:
        ...
    def GetDeterminant(self) -> float:
        ...
    def GetInverse(self) -> Matrix2f:
        ...
    def GetRow(self, arg0: int) -> Vec2f:
        ...
    def GetTranspose(self) -> Matrix2f:
        ...
    def Set(self, arg0: float, arg1: float, arg2: float, arg3: float) -> Matrix2f:
        ...
    def SetArrayItem(self, arg0: int, arg1: float) -> None:
        ...
    def SetColumn(self, arg0: int, arg1: Vec2f) -> None:
        ...
    @typing.overload
    def SetDiagonal(self, arg0: float) -> Matrix2f:
        ...
    @typing.overload
    def SetDiagonal(self, arg0: Vec2f) -> Matrix2f:
        ...
    def SetIdentity(self) -> Matrix2f:
        ...
    def SetRow(self, arg0: int, arg1: Vec2f) -> None:
        ...
    def SetZero(self) -> Matrix2f:
        ...
    def __add__(self, arg0: Matrix2f) -> Matrix2f:
        ...
    def __contains__(self, arg0: float) -> bool:
        ...
    def __copy__(self) -> Matrix2f:
        ...
    def __deepcopy__(self, memo: dict) -> Matrix2f:
        ...
    @typing.overload
    def __eq__(self, arg0: Matrix2d) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: Matrix2f) -> bool:
        ...
    @typing.overload
    def __getitem__(self, arg0: tuple) -> float:
        ...
    @typing.overload
    def __getitem__(self, arg0: int) -> Vec2f:
        ...
    @typing.overload
    def __getitem__(self, arg0: int) -> Vec2f:
        ...
    def __iadd__(self, arg0: Matrix2f) -> Matrix2f:
        ...
    def __imul__(self, arg0: float) -> Matrix2f:
        ...
    @typing.overload
    def __init__(self, arg0: Matrix2d) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Matrix2f) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing_extensions.Buffer) -> None:
        ...
    def __isub__(self, arg0: Matrix2f) -> Matrix2f:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> Matrix2f:
        ...
    @typing.overload
    def __mul__(self, arg0: Matrix2f) -> Matrix2f:
        ...
    @typing.overload
    def __mul__(self, arg0: Vec2f) -> Vec2f:
        ...
    @typing.overload
    def __ne__(self, arg0: Matrix2d) -> bool:
        ...
    @typing.overload
    def __ne__(self, arg0: Matrix2f) -> bool:
        ...
    def __neg__(self) -> Matrix2f:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> Matrix2f:
        ...
    @typing.overload
    def __rmul__(self, arg0: Vec2f) -> Vec2f:
        ...
    @typing.overload
    def __setitem__(self, arg0: tuple, arg1: float) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: Vec2f) -> None:
        ...
    def __str__(self) -> str:
        ...
    def __sub__(self, arg0: Matrix2f) -> Matrix2f:
        ...
    def __truediv__(self, arg0: Matrix2f) -> Matrix2f:
        ...
class Matrix3d:
    __hash__: typing.ClassVar[None] = None
    dimension: typing.ClassVar[tuple] = (3, 3)
    def DecomposeRotation(self, axis0: Vec3d, axis1: Vec3d, axis2: Vec3d) -> Vec3d:
        ...
    @typing.overload
    def ExtractRotation(self) -> ...:
        ...
    @typing.overload
    def ExtractRotation(self) -> ...:
        ...
    def ExtractRotationQuaternion(self) -> ...:
        ...
    def GetArrayItem(self, arg0: int) -> float:
        ...
    def GetColumn(self, arg0: int) -> Vec3d:
        ...
    def GetDeterminant(self) -> float:
        ...
    def GetHandedness(self) -> int:
        ...
    def GetInverse(self) -> Matrix3d:
        ...
    def GetOrthonormalized(self) -> Matrix3d:
        ...
    def GetRow(self, arg0: int) -> Vec3d:
        ...
    def GetTranspose(self) -> Matrix3d:
        ...
    def IsLeftHanded(self) -> bool:
        ...
    def IsRightHanded(self) -> bool:
        ...
    def Orthonormalize(self) -> bool:
        ...
    def Set(self, arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float) -> Matrix3d:
        ...
    def SetArrayItem(self, arg0: int, arg1: float) -> None:
        ...
    def SetColumn(self, arg0: int, arg1: Vec3d) -> None:
        ...
    @typing.overload
    def SetDiagonal(self, arg0: float) -> Matrix3d:
        ...
    @typing.overload
    def SetDiagonal(self, arg0: Vec3d) -> Matrix3d:
        ...
    def SetGfRotation(self, arg0: ...) -> Matrix3d:
        ...
    def SetIdentity(self) -> Matrix3d:
        ...
    @typing.overload
    def SetRotate(self, arg0: ...) -> Matrix3d:
        ...
    @typing.overload
    def SetRotate(self, arg0: ...) -> Matrix3d:
        ...
    def SetRow(self, arg0: int, arg1: Vec3d) -> None:
        ...
    @typing.overload
    def SetScale(self, arg0: float) -> Matrix3d:
        ...
    @typing.overload
    def SetScale(self, arg0: Vec3d) -> Matrix3d:
        ...
    def SetZero(self) -> Matrix3d:
        ...
    def __add__(self, arg0: Matrix3d) -> Matrix3d:
        ...
    def __contains__(self, arg0: float) -> bool:
        ...
    def __copy__(self) -> Matrix3d:
        ...
    def __deepcopy__(self, memo: dict) -> Matrix3d:
        ...
    @typing.overload
    def __eq__(self, arg0: Matrix3d) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: ...) -> bool:
        ...
    @typing.overload
    def __getitem__(self, arg0: tuple) -> float:
        ...
    @typing.overload
    def __getitem__(self, arg0: int) -> Vec3d:
        ...
    @typing.overload
    def __getitem__(self, arg0: int) -> Vec3d:
        ...
    def __iadd__(self, arg0: Matrix3d) -> Matrix3d:
        ...
    def __imul__(self, arg0: float) -> Matrix3d:
        ...
    @typing.overload
    def __init__(self, arg0: Matrix3d) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: ...) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec3d) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: ...) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: ...) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing_extensions.Buffer) -> None:
        ...
    def __isub__(self, arg0: Matrix3d) -> Matrix3d:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> Matrix3d:
        ...
    @typing.overload
    def __mul__(self, arg0: Matrix3d) -> Matrix3d:
        ...
    @typing.overload
    def __mul__(self, arg0: Vec3d) -> Vec3d:
        ...
    @typing.overload
    def __mul__(self, arg0: Vec3f) -> Vec3f:
        ...
    @typing.overload
    def __ne__(self, arg0: Matrix3d) -> bool:
        ...
    @typing.overload
    def __ne__(self, arg0: ...) -> bool:
        ...
    def __neg__(self) -> Matrix3d:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> Matrix3d:
        ...
    @typing.overload
    def __rmul__(self, arg0: Vec3d) -> Vec3d:
        ...
    @typing.overload
    def __rmul__(self, arg0: Vec3f) -> Vec3f:
        ...
    @typing.overload
    def __setitem__(self, arg0: tuple, arg1: float) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: Vec3d) -> None:
        ...
    def __str__(self) -> str:
        ...
    def __sub__(self, arg0: Matrix3d) -> Matrix3d:
        ...
    def __truediv__(self, arg0: Matrix3d) -> Matrix3d:
        ...
class Matrix3f:
    __hash__: typing.ClassVar[None] = None
    dimension: typing.ClassVar[tuple] = (3, 3)
    def DecomposeRotation(self, axis0: Vec3f, axis1: Vec3f, axis2: Vec3f) -> Vec3f:
        ...
    @typing.overload
    def ExtractRotation(self) -> ...:
        ...
    @typing.overload
    def ExtractRotation(self) -> ...:
        ...
    def ExtractRotationQuaternion(self) -> ...:
        ...
    def GetArrayItem(self, arg0: int) -> float:
        ...
    def GetColumn(self, arg0: int) -> Vec3f:
        ...
    def GetDeterminant(self) -> float:
        ...
    def GetHandedness(self) -> int:
        ...
    def GetInverse(self) -> Matrix3f:
        ...
    def GetOrthonormalized(self) -> Matrix3f:
        ...
    def GetRow(self, arg0: int) -> Vec3f:
        ...
    def GetTranspose(self) -> Matrix3f:
        ...
    def IsLeftHanded(self) -> bool:
        ...
    def IsRightHanded(self) -> bool:
        ...
    def Orthonormalize(self) -> bool:
        ...
    def Set(self, arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float) -> Matrix3f:
        ...
    def SetArrayItem(self, arg0: int, arg1: float) -> None:
        ...
    def SetColumn(self, arg0: int, arg1: Vec3f) -> None:
        ...
    @typing.overload
    def SetDiagonal(self, arg0: float) -> Matrix3f:
        ...
    @typing.overload
    def SetDiagonal(self, arg0: Vec3f) -> Matrix3f:
        ...
    def SetGfRotation(self, arg0: ...) -> Matrix3f:
        ...
    def SetIdentity(self) -> Matrix3f:
        ...
    @typing.overload
    def SetRotate(self, arg0: ...) -> Matrix3f:
        ...
    @typing.overload
    def SetRotate(self, arg0: ...) -> Matrix3f:
        ...
    def SetRow(self, arg0: int, arg1: Vec3f) -> None:
        ...
    @typing.overload
    def SetScale(self, arg0: float) -> Matrix3f:
        ...
    @typing.overload
    def SetScale(self, arg0: Vec3f) -> Matrix3f:
        ...
    def SetZero(self) -> Matrix3f:
        ...
    def __add__(self, arg0: Matrix3f) -> Matrix3f:
        ...
    def __contains__(self, arg0: float) -> bool:
        ...
    def __copy__(self) -> Matrix3f:
        ...
    def __deepcopy__(self, memo: dict) -> Matrix3f:
        ...
    @typing.overload
    def __eq__(self, arg0: Matrix3d) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: Matrix3f) -> bool:
        ...
    @typing.overload
    def __getitem__(self, arg0: tuple) -> float:
        ...
    @typing.overload
    def __getitem__(self, arg0: int) -> Vec3f:
        ...
    @typing.overload
    def __getitem__(self, arg0: int) -> Vec3f:
        ...
    def __iadd__(self, arg0: Matrix3f) -> Matrix3f:
        ...
    def __imul__(self, arg0: float) -> Matrix3f:
        ...
    @typing.overload
    def __init__(self, arg0: Matrix3d) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Matrix3f) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec3f) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: ...) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: ...) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing_extensions.Buffer) -> None:
        ...
    def __isub__(self, arg0: Matrix3f) -> Matrix3f:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> Matrix3f:
        ...
    @typing.overload
    def __mul__(self, arg0: Matrix3f) -> Matrix3f:
        ...
    @typing.overload
    def __mul__(self, arg0: Vec3f) -> Vec3f:
        ...
    @typing.overload
    def __ne__(self, arg0: Matrix3d) -> bool:
        ...
    @typing.overload
    def __ne__(self, arg0: Matrix3f) -> bool:
        ...
    def __neg__(self) -> Matrix3f:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> Matrix3f:
        ...
    @typing.overload
    def __rmul__(self, arg0: Vec3f) -> Vec3f:
        ...
    @typing.overload
    def __setitem__(self, arg0: tuple, arg1: float) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: Vec3f) -> None:
        ...
    def __str__(self) -> str:
        ...
    def __sub__(self, arg0: Matrix3f) -> Matrix3f:
        ...
    def __truediv__(self, arg0: Matrix3f) -> Matrix3f:
        ...
class Matrix4d:
    __hash__: typing.ClassVar[None] = None
    dimension: typing.ClassVar[tuple] = (4, 4)
    def DecomposeRotation(self, axis0: Vec3d, axis1: Vec3d, axis2: Vec3d) -> Vec3d:
        ...
    def ExtractRotation(self) -> ...:
        ...
    def ExtractRotationMatrix(self) -> ...:
        ...
    def ExtractRotationQuat(self) -> ...:
        ...
    def ExtractTranslation(self) -> Vec3d:
        ...
    def Factor(self) -> tuple:
        ...
    def FactorWithEpsilon(self, arg0: float) -> tuple:
        ...
    def GetArrayItem(self, arg0: int) -> float:
        ...
    def GetColumn(self, arg0: int) -> Vec4d:
        ...
    def GetDeterminant(self) -> float:
        ...
    def GetDeterminant3(self) -> float:
        ...
    def GetHandedness(self) -> int:
        ...
    def GetInverse(self) -> Matrix4d:
        ...
    def GetOrthonormalized(self) -> Matrix4d:
        ...
    def GetRow(self, arg0: int) -> Vec4d:
        ...
    def GetRow3(self, arg0: int) -> Vec3d:
        ...
    def GetTranspose(self) -> Matrix4d:
        ...
    def IsLeftHanded(self) -> bool:
        ...
    def IsRightHanded(self) -> bool:
        ...
    def Orthonormalize(self) -> bool:
        ...
    def RemoveScaleShear(self) -> Matrix4d:
        ...
    def Set(self, arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float, arg10: float, arg11: float, arg12: float, arg13: float, arg14: float, arg15: float) -> Matrix4d:
        ...
    def SetArrayItem(self, arg0: int, arg1: float) -> None:
        ...
    def SetColumn(self, arg0: int, arg1: Vec4d) -> None:
        ...
    @typing.overload
    def SetDiagonal(self, arg0: float) -> Matrix4d:
        ...
    @typing.overload
    def SetDiagonal(self, arg0: Vec4d) -> Matrix4d:
        ...
    def SetIdentity(self) -> Matrix4d:
        ...
    @typing.overload
    def SetLookAt(self, arg0: Vec3d, arg1: Vec3d, arg2: Vec3d) -> Matrix4d:
        ...
    @typing.overload
    def SetLookAt(self, arg0: Vec3d, arg1: ...) -> Matrix4d:
        ...
    @typing.overload
    def SetLookAt(self, arg0: Vec3d, arg1: ...) -> Matrix4d:
        ...
    @typing.overload
    def SetRotate(self, arg0: ...) -> Matrix4d:
        ...
    @typing.overload
    def SetRotate(self, arg0: ...) -> Matrix4d:
        ...
    @typing.overload
    def SetRotate(self, arg0: ...) -> Matrix4d:
        ...
    @typing.overload
    def SetRotateOnly(self, arg0: ...) -> Matrix4d:
        ...
    @typing.overload
    def SetRotateOnly(self, arg0: ...) -> Matrix4d:
        ...
    @typing.overload
    def SetRotateOnly(self, arg0: ...) -> Matrix4d:
        ...
    def SetRow(self, arg0: int, arg1: Vec4d) -> None:
        ...
    def SetRow3(self, arg0: int, arg1: Vec3d) -> None:
        ...
    @typing.overload
    def SetScale(self, arg0: float) -> Matrix4d:
        ...
    @typing.overload
    def SetScale(self, arg0: Vec3d) -> Matrix4d:
        ...
    @typing.overload
    def SetTransform(self, arg0: ..., arg1: Vec3d) -> Matrix4d:
        ...
    @typing.overload
    def SetTransform(self, arg0: ..., arg1: Vec3d) -> Matrix4d:
        ...
    def SetTranslate(self, arg0: Vec3d) -> Matrix4d:
        ...
    def SetTranslateOnly(self, arg0: Vec3d) -> Matrix4d:
        ...
    def SetZero(self) -> Matrix4d:
        ...
    @typing.overload
    def Transform(self, arg0: Vec3f) -> Vec3f:
        ...
    @typing.overload
    def Transform(self, arg0: Vec3d) -> Vec3d:
        ...
    @typing.overload
    def TransformAffine(self, arg0: Vec3f) -> Vec3f:
        ...
    @typing.overload
    def TransformAffine(self, arg0: Vec3d) -> Vec3d:
        ...
    @typing.overload
    def TransformDir(self, arg0: Vec3f) -> Vec3f:
        ...
    @typing.overload
    def TransformDir(self, arg0: Vec3d) -> Vec3d:
        ...
    def __add__(self, arg0: Matrix4d) -> Matrix4d:
        ...
    def __contains__(self, arg0: float) -> bool:
        ...
    def __copy__(self) -> Matrix4d:
        ...
    def __deepcopy__(self, memo: dict) -> Matrix4d:
        ...
    @typing.overload
    def __eq__(self, arg0: Matrix4d) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: ...) -> bool:
        ...
    @typing.overload
    def __getitem__(self, arg0: tuple) -> float:
        ...
    @typing.overload
    def __getitem__(self, arg0: int) -> Vec4d:
        ...
    def __iadd__(self, arg0: Matrix4d) -> Matrix4d:
        ...
    def __imul__(self, arg0: float) -> Matrix4d:
        ...
    @typing.overload
    def __init__(self, arg0: Matrix4d) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: ...) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float, arg10: float, arg11: float, arg12: float, arg13: float, arg14: float, arg15: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec4d) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: ..., arg1: Vec3d) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: ..., arg1: Vec3d) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing_extensions.Buffer) -> None:
        ...
    def __isub__(self, arg0: Matrix4d) -> Matrix4d:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> Matrix4d:
        ...
    @typing.overload
    def __mul__(self, arg0: Matrix4d) -> Matrix4d:
        ...
    @typing.overload
    def __mul__(self, arg0: Vec4d) -> Vec4d:
        ...
    @typing.overload
    def __mul__(self, arg0: Vec4f) -> Vec4f:
        ...
    @typing.overload
    def __ne__(self, arg0: Matrix4d) -> bool:
        ...
    @typing.overload
    def __ne__(self, arg0: ...) -> bool:
        ...
    def __neg__(self) -> Matrix4d:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> Matrix4d:
        ...
    @typing.overload
    def __rmul__(self, arg0: Vec4d) -> Vec4d:
        ...
    @typing.overload
    def __rmul__(self, arg0: Vec4f) -> Vec4f:
        ...
    @typing.overload
    def __setitem__(self, arg0: tuple, arg1: float) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: Vec4d) -> None:
        ...
    def __str__(self) -> str:
        ...
    def __sub__(self, arg0: Matrix4d) -> Matrix4d:
        ...
    def __truediv__(self, arg0: Matrix4d) -> Matrix4d:
        ...
class Matrix4f:
    __hash__: typing.ClassVar[None] = None
    dimension: typing.ClassVar[tuple] = (4, 4)
    def DecomposeRotation(self, axis0: Vec3f, axis1: Vec3f, axis2: Vec3f) -> Vec3f:
        ...
    def ExtractRotation(self) -> ...:
        ...
    def ExtractRotationMatrix(self) -> ...:
        ...
    def ExtractRotationQuat(self) -> ...:
        ...
    def ExtractTranslation(self) -> Vec3f:
        ...
    def Factor(self) -> tuple:
        ...
    def FactorWithEpsilon(self, arg0: float) -> tuple:
        ...
    def GetArrayItem(self, arg0: int) -> float:
        ...
    def GetColumn(self, arg0: int) -> Vec4f:
        ...
    def GetDeterminant(self) -> float:
        ...
    def GetDeterminant3(self) -> float:
        ...
    def GetHandedness(self) -> int:
        ...
    def GetInverse(self) -> Matrix4f:
        ...
    def GetOrthonormalized(self) -> Matrix4f:
        ...
    def GetRow(self, arg0: int) -> Vec4f:
        ...
    def GetRow3(self, arg0: int) -> Vec3f:
        ...
    def GetTranspose(self) -> Matrix4f:
        ...
    def IsLeftHanded(self) -> bool:
        ...
    def IsRightHanded(self) -> bool:
        ...
    def Orthonormalize(self) -> bool:
        ...
    def RemoveScaleShear(self) -> Matrix4f:
        ...
    def Set(self, arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float, arg10: float, arg11: float, arg12: float, arg13: float, arg14: float, arg15: float) -> Matrix4f:
        ...
    def SetArrayItem(self, arg0: int, arg1: float) -> None:
        ...
    def SetColumn(self, arg0: int, arg1: Vec4f) -> None:
        ...
    @typing.overload
    def SetDiagonal(self, arg0: float) -> Matrix4f:
        ...
    @typing.overload
    def SetDiagonal(self, arg0: Vec4f) -> Matrix4f:
        ...
    def SetIdentity(self) -> Matrix4f:
        ...
    @typing.overload
    def SetLookAt(self, arg0: Vec3f, arg1: Vec3f, arg2: Vec3f) -> Matrix4f:
        ...
    @typing.overload
    def SetLookAt(self, arg0: Vec3f, arg1: ...) -> Matrix4f:
        ...
    @typing.overload
    def SetLookAt(self, arg0: Vec3f, arg1: ...) -> Matrix4f:
        ...
    @typing.overload
    def SetRotate(self, arg0: ...) -> Matrix4f:
        ...
    @typing.overload
    def SetRotate(self, arg0: ...) -> Matrix4f:
        ...
    @typing.overload
    def SetRotate(self, arg0: ...) -> Matrix4f:
        ...
    @typing.overload
    def SetRotateOnly(self, arg0: ...) -> Matrix4f:
        ...
    @typing.overload
    def SetRotateOnly(self, arg0: ...) -> Matrix4f:
        ...
    @typing.overload
    def SetRotateOnly(self, arg0: ...) -> Matrix4f:
        ...
    def SetRow(self, arg0: int, arg1: Vec4f) -> None:
        ...
    def SetRow3(self, arg0: int, arg1: Vec3f) -> None:
        ...
    @typing.overload
    def SetScale(self, arg0: float) -> Matrix4f:
        ...
    @typing.overload
    def SetScale(self, arg0: Vec3f) -> Matrix4f:
        ...
    @typing.overload
    def SetTransform(self, arg0: ..., arg1: Vec3f) -> Matrix4f:
        ...
    @typing.overload
    def SetTransform(self, arg0: ..., arg1: Vec3f) -> Matrix4f:
        ...
    def SetTranslate(self, arg0: Vec3f) -> Matrix4f:
        ...
    def SetTranslateOnly(self, arg0: Vec3f) -> Matrix4f:
        ...
    def SetZero(self) -> Matrix4f:
        ...
    @typing.overload
    def Transform(self, arg0: Vec3f) -> Vec3f:
        ...
    @typing.overload
    def Transform(self, arg0: Vec3d) -> Vec3d:
        ...
    @typing.overload
    def TransformAffine(self, arg0: Vec3f) -> Vec3f:
        ...
    @typing.overload
    def TransformAffine(self, arg0: Vec3d) -> Vec3d:
        ...
    @typing.overload
    def TransformDir(self, arg0: Vec3f) -> Vec3f:
        ...
    @typing.overload
    def TransformDir(self, arg0: Vec3d) -> Vec3d:
        ...
    def __add__(self, arg0: Matrix4f) -> Matrix4f:
        ...
    def __contains__(self, arg0: float) -> bool:
        ...
    def __copy__(self) -> Matrix4f:
        ...
    def __deepcopy__(self, memo: dict) -> Matrix4f:
        ...
    @typing.overload
    def __eq__(self, arg0: Matrix4d) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: Matrix4f) -> bool:
        ...
    @typing.overload
    def __getitem__(self, arg0: tuple) -> float:
        ...
    @typing.overload
    def __getitem__(self, arg0: int) -> Vec4f:
        ...
    def __iadd__(self, arg0: Matrix4f) -> Matrix4f:
        ...
    def __imul__(self, arg0: float) -> Matrix4f:
        ...
    @typing.overload
    def __init__(self, arg0: Matrix4d) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Matrix4f) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float, arg7: float, arg8: float, arg9: float, arg10: float, arg11: float, arg12: float, arg13: float, arg14: float, arg15: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec4f) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: ..., arg1: Vec3f) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: ..., arg1: Vec3f) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing_extensions.Buffer) -> None:
        ...
    def __isub__(self, arg0: Matrix4f) -> Matrix4f:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> Matrix4f:
        ...
    @typing.overload
    def __mul__(self, arg0: Matrix4f) -> Matrix4f:
        ...
    @typing.overload
    def __mul__(self, arg0: Vec4f) -> Vec4f:
        ...
    @typing.overload
    def __ne__(self, arg0: Matrix4d) -> bool:
        ...
    @typing.overload
    def __ne__(self, arg0: Matrix4f) -> bool:
        ...
    def __neg__(self) -> Matrix4f:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> Matrix4f:
        ...
    @typing.overload
    def __rmul__(self, arg0: Vec4f) -> Vec4f:
        ...
    @typing.overload
    def __setitem__(self, arg0: tuple, arg1: float) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: Vec4f) -> None:
        ...
    def __str__(self) -> str:
        ...
    def __sub__(self, arg0: Matrix4f) -> Matrix4f:
        ...
    def __truediv__(self, arg0: Matrix4f) -> Matrix4f:
        ...
class Plane:
    __hash__: typing.ClassVar[None] = None
    def GetDistance(self, p: Vec3d) -> float:
        ...
    def GetDistanceFromOrigin(self) -> float:
        ...
    def GetEquation(self) -> Vec4d:
        ...
    def GetNormal(self) -> Vec3d:
        ...
    @typing.overload
    def IntersectsPositiveHalfSpace(self, box: Range3d) -> bool:
        ...
    @typing.overload
    def IntersectsPositiveHalfSpace(self, pt: Vec3d) -> bool:
        ...
    def Project(self, p: Vec3d) -> Vec3d:
        ...
    def Reorient(self, p: Vec3d) -> Plane:
        ...
    @typing.overload
    def Set(self, normal: Vec3d, distanceToOrigin: float) -> Plane:
        ...
    @typing.overload
    def Set(self, normal: Vec3d, point: Vec3d) -> Plane:
        ...
    @typing.overload
    def Set(self, p0: Vec3d, p1: Vec3d, p2: Vec3d) -> Plane:
        ...
    @typing.overload
    def Set(self, eqn: Vec4d) -> Plane:
        ...
    def Transform(self, matrix: Matrix4d) -> Plane:
        ...
    def __eq__(self, arg0: Plane) -> bool:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, normal: Vec3d, distanceToOrigin: float) -> None:
        ...
    @typing.overload
    def __init__(self, normal: Vec3d, distanceToOrigin: int) -> None:
        ...
    @typing.overload
    def __init__(self, normal: Vec3d, point: Vec3d) -> None:
        ...
    @typing.overload
    def __init__(self, p0: Vec3d, p1: Vec3d, p2: Vec3d) -> None:
        ...
    @typing.overload
    def __init__(self, eqn: Vec4d) -> None:
        ...
    def __ne__(self, arg0: Plane) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    @property
    def distanceFromOrigin(self) -> float:
        ...
    @property
    def normal(self) -> Vec3d:
        ...
class Quatd:
    __hash__: typing.ClassVar[None] = None
    imaginary: Vec3d
    real: float
    @staticmethod
    def GetIdentity() -> Quatd:
        ...
    def Dot(self, arg0: Quatd) -> float:
        ...
    def GetConjugate(self) -> Quatd:
        ...
    def GetImaginary(self) -> Vec3d:
        ...
    def GetInverse(self) -> Quatd:
        ...
    def GetLength(self) -> float:
        ...
    def GetLengthSq(self) -> float:
        ...
    def GetNormalized(self) -> Quatd:
        ...
    def GetReal(self) -> float:
        ...
    def Normalize(self) -> float:
        ...
    @typing.overload
    def SetImaginary(self, imaginary: Vec3d) -> None:
        ...
    @typing.overload
    def SetImaginary(self, i: float, j: float, k: float) -> None:
        ...
    def SetReal(self, real: float) -> None:
        ...
    def Transform(self, point: Vec3d) -> Vec3d:
        ...
    def __add__(self, arg0: Quatd) -> Quatd:
        ...
    def __copy__(self) -> Quatd:
        ...
    def __deepcopy__(self, memo: dict) -> Quatd:
        ...
    def __eq__(self, arg0: Quatd) -> bool:
        ...
    @typing.overload
    def __getitem__(self, arg0: int) -> float:
        ...
    @typing.overload
    def __getitem__(self, arg0: slice) -> list[float]:
        ...
    def __iadd__(self, arg0: Quatd) -> Quatd:
        ...
    @typing.overload
    def __imul__(self, arg0: Quatd) -> Quatd:
        ...
    @typing.overload
    def __imul__(self, arg0: float) -> Quatd:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: Vec3d) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: tuple[float, float, float]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Quatd) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: ...) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: ...) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing_extensions.Buffer) -> None:
        ...
    def __isub__(self, arg0: Quatd) -> Quatd:
        ...
    def __itruediv__(self, arg0: float) -> Quatd:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: Quatd) -> Quatd:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> Quatd:
        ...
    def __ne__(self, arg0: Quatd) -> bool:
        ...
    def __neg__(self) -> Quatd:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: float) -> Quatd:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: float) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: typing.Sequence) -> None:
        ...
    def __str__(self) -> str:
        ...
    def __sub__(self, arg0: Quatd) -> Quatd:
        ...
    def __truediv__(self, arg0: float) -> Quatd:
        ...
class Quatf:
    __hash__: typing.ClassVar[None] = None
    imaginary: Vec3f
    real: float
    @staticmethod
    def GetIdentity() -> Quatf:
        ...
    def Dot(self, arg0: Quatf) -> float:
        ...
    def GetConjugate(self) -> Quatf:
        ...
    def GetImaginary(self) -> Vec3f:
        ...
    def GetInverse(self) -> Quatf:
        ...
    def GetLength(self) -> float:
        ...
    def GetLengthSq(self) -> float:
        ...
    def GetNormalized(self) -> Quatf:
        ...
    def GetReal(self) -> float:
        ...
    def Normalize(self) -> float:
        ...
    @typing.overload
    def SetImaginary(self, imaginary: Vec3f) -> None:
        ...
    @typing.overload
    def SetImaginary(self, i: float, j: float, k: float) -> None:
        ...
    def SetReal(self, real: float) -> None:
        ...
    def Transform(self, point: Vec3f) -> Vec3f:
        ...
    def __add__(self, arg0: Quatf) -> Quatf:
        ...
    def __copy__(self) -> Quatf:
        ...
    def __deepcopy__(self, memo: dict) -> Quatf:
        ...
    def __eq__(self, arg0: Quatf) -> bool:
        ...
    @typing.overload
    def __getitem__(self, arg0: int) -> float:
        ...
    @typing.overload
    def __getitem__(self, arg0: slice) -> list[float]:
        ...
    def __iadd__(self, arg0: Quatf) -> Quatf:
        ...
    @typing.overload
    def __imul__(self, arg0: Quatf) -> Quatf:
        ...
    @typing.overload
    def __imul__(self, arg0: float) -> Quatf:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: Vec3f) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: tuple[float, float, float]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Quatd) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Quatf) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: ...) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing_extensions.Buffer) -> None:
        ...
    def __isub__(self, arg0: Quatf) -> Quatf:
        ...
    def __itruediv__(self, arg0: float) -> Quatf:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: Quatf) -> Quatf:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> Quatf:
        ...
    def __ne__(self, arg0: Quatf) -> bool:
        ...
    def __neg__(self) -> Quatf:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: float) -> Quatf:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: float) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: typing.Sequence) -> None:
        ...
    def __str__(self) -> str:
        ...
    def __sub__(self, arg0: Quatf) -> Quatf:
        ...
    def __truediv__(self, arg0: float) -> Quatf:
        ...
class Quath:
    __hash__: typing.ClassVar[None] = None
    imaginary: Vec3h
    real: GfHalf
    @staticmethod
    def GetIdentity() -> Quath:
        ...
    def Dot(self, arg0: Quath) -> GfHalf:
        ...
    def GetConjugate(self) -> Quath:
        ...
    def GetImaginary(self) -> Vec3h:
        ...
    def GetInverse(self) -> Quath:
        ...
    def GetLength(self) -> float:
        ...
    def GetLengthSq(self) -> GfHalf:
        ...
    def GetNormalized(self) -> Quath:
        ...
    def GetReal(self) -> GfHalf:
        ...
    def Normalize(self) -> float:
        ...
    @typing.overload
    def SetImaginary(self, imaginary: Vec3h) -> None:
        ...
    @typing.overload
    def SetImaginary(self, i: GfHalf, j: GfHalf, k: GfHalf) -> None:
        ...
    def SetReal(self, real: GfHalf) -> None:
        ...
    def Transform(self, point: Vec3h) -> Vec3h:
        ...
    def __add__(self, arg0: Quath) -> Quath:
        ...
    def __copy__(self) -> Quath:
        ...
    def __deepcopy__(self, memo: dict) -> Quath:
        ...
    def __eq__(self, arg0: Quath) -> bool:
        ...
    @typing.overload
    def __getitem__(self, arg0: int) -> GfHalf:
        ...
    @typing.overload
    def __getitem__(self, arg0: slice) -> list[GfHalf]:
        ...
    def __iadd__(self, arg0: Quath) -> Quath:
        ...
    @typing.overload
    def __imul__(self, arg0: Quath) -> Quath:
        ...
    @typing.overload
    def __imul__(self, arg0: GfHalf) -> Quath:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: GfHalf) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: GfHalf, arg1: GfHalf, arg2: GfHalf, arg3: GfHalf) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: GfHalf, arg1: Vec3h) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: GfHalf, arg1: tuple[GfHalf, GfHalf, GfHalf]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Quatd) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Quatf) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Quath) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing_extensions.Buffer) -> None:
        ...
    def __isub__(self, arg0: Quath) -> Quath:
        ...
    def __itruediv__(self, arg0: GfHalf) -> Quath:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: Quath) -> Quath:
        ...
    @typing.overload
    def __mul__(self, arg0: GfHalf) -> Quath:
        ...
    def __ne__(self, arg0: Quath) -> bool:
        ...
    def __neg__(self) -> Quath:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: GfHalf) -> Quath:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: GfHalf) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: typing.Sequence) -> None:
        ...
    def __str__(self) -> str:
        ...
    def __sub__(self, arg0: Quath) -> Quath:
        ...
    def __truediv__(self, arg0: GfHalf) -> Quath:
        ...
class Range1d:
    __hash__: typing.ClassVar[None] = None
    max: float
    min: float
    @staticmethod
    def GetIntersection(arg0: Range1d, arg1: Range1d) -> Range1d:
        ...
    @staticmethod
    def GetUnion(arg0: Range1d, arg1: Range1d) -> Range1d:
        ...
    @typing.overload
    def Contains(self, arg0: float) -> bool:
        ...
    @typing.overload
    def Contains(self, arg0: Range1d) -> bool:
        ...
    def GetDistanceSquared(self, arg0: float) -> float:
        ...
    def GetMax(self) -> float:
        ...
    def GetMidpoint(self) -> float:
        ...
    def GetMin(self) -> float:
        ...
    def GetSize(self) -> float:
        ...
    def IntersectWith(self, arg0: Range1d) -> Range1d:
        ...
    def IsEmpty(self) -> bool:
        ...
    def SetEmpty(self) -> None:
        ...
    def SetMax(self, arg0: float) -> None:
        ...
    def SetMin(self, arg0: float) -> None:
        ...
    @typing.overload
    def UnionWith(self, arg0: float) -> Range1d:
        ...
    @typing.overload
    def UnionWith(self, arg0: Range1d) -> Range1d:
        ...
    def __add__(self, arg0: Range1d) -> Range1d:
        ...
    def __copy__(self) -> Range1d:
        ...
    def __deepcopy__(self, memo: dict) -> Range1d:
        ...
    def __eq__(self, arg0: Range1d) -> bool:
        ...
    def __iadd__(self, arg0: Range1d) -> Range1d:
        ...
    def __imul__(self, arg0: float) -> Range1d:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Range1d) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float) -> None:
        ...
    def __isub__(self, arg0: Range1d) -> Range1d:
        ...
    def __itruediv__(self, arg0: float) -> Range1d:
        ...
    def __mul__(self, arg0: float) -> Range1d:
        ...
    def __ne__(self, arg0: Range1d) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: float) -> Range1d:
        ...
    def __str__(self) -> str:
        ...
    def __sub__(self, arg0: Range1d) -> Range1d:
        ...
    def __truediv__(self, arg0: float) -> Range1d:
        ...
class Range1f:
    __hash__: typing.ClassVar[None] = None
    max: float
    min: float
    @staticmethod
    def GetIntersection(arg0: Range1f, arg1: Range1f) -> Range1f:
        ...
    @staticmethod
    def GetUnion(arg0: Range1f, arg1: Range1f) -> Range1f:
        ...
    @typing.overload
    def Contains(self, arg0: float) -> bool:
        ...
    @typing.overload
    def Contains(self, arg0: Range1f) -> bool:
        ...
    def GetDistanceSquared(self, arg0: float) -> float:
        ...
    def GetMax(self) -> float:
        ...
    def GetMidpoint(self) -> float:
        ...
    def GetMin(self) -> float:
        ...
    def GetSize(self) -> float:
        ...
    def IntersectWith(self, arg0: Range1f) -> Range1f:
        ...
    def IsEmpty(self) -> bool:
        ...
    def SetEmpty(self) -> None:
        ...
    def SetMax(self, arg0: float) -> None:
        ...
    def SetMin(self, arg0: float) -> None:
        ...
    @typing.overload
    def UnionWith(self, arg0: float) -> Range1f:
        ...
    @typing.overload
    def UnionWith(self, arg0: Range1f) -> Range1f:
        ...
    def __add__(self, arg0: Range1f) -> Range1f:
        ...
    def __copy__(self) -> Range1f:
        ...
    def __deepcopy__(self, memo: dict) -> Range1f:
        ...
    def __eq__(self, arg0: Range1f) -> bool:
        ...
    def __iadd__(self, arg0: Range1f) -> Range1f:
        ...
    def __imul__(self, arg0: float) -> Range1f:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Range1f) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float) -> None:
        ...
    def __isub__(self, arg0: Range1f) -> Range1f:
        ...
    def __itruediv__(self, arg0: float) -> Range1f:
        ...
    def __mul__(self, arg0: float) -> Range1f:
        ...
    def __ne__(self, arg0: Range1f) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: float) -> Range1f:
        ...
    def __str__(self) -> str:
        ...
    def __sub__(self, arg0: Range1f) -> Range1f:
        ...
    def __truediv__(self, arg0: float) -> Range1f:
        ...
class Range2d:
    __hash__: typing.ClassVar[None] = None
    max: Vec2d
    min: Vec2d
    @staticmethod
    def GetIntersection(arg0: Range2d, arg1: Range2d) -> Range2d:
        ...
    @staticmethod
    def GetUnion(arg0: Range2d, arg1: Range2d) -> Range2d:
        ...
    @staticmethod
    def unitSquare() -> Range2d:
        ...
    @typing.overload
    def Contains(self, arg0: Vec2d) -> bool:
        ...
    @typing.overload
    def Contains(self, arg0: Range2d) -> bool:
        ...
    def GetCorner(self, arg0: int) -> Vec2d:
        ...
    def GetDistanceSquared(self, arg0: Vec2d) -> float:
        ...
    def GetMax(self) -> Vec2d:
        ...
    def GetMidpoint(self) -> Vec2d:
        ...
    def GetMin(self) -> Vec2d:
        ...
    def GetQuadrant(self, arg0: int) -> Range2d:
        ...
    def GetSize(self) -> Vec2d:
        ...
    def IntersectWith(self, arg0: Range2d) -> Range2d:
        ...
    def IsEmpty(self) -> bool:
        ...
    def SetEmpty(self) -> None:
        ...
    def SetMax(self, arg0: Vec2d) -> None:
        ...
    def SetMin(self, arg0: Vec2d) -> None:
        ...
    @typing.overload
    def UnionWith(self, arg0: Vec2d) -> Range2d:
        ...
    @typing.overload
    def UnionWith(self, arg0: Range2d) -> Range2d:
        ...
    def __add__(self, arg0: Range2d) -> Range2d:
        ...
    def __copy__(self) -> Range2d:
        ...
    def __deepcopy__(self, memo: dict) -> Range2d:
        ...
    def __eq__(self, arg0: Range2d) -> bool:
        ...
    def __iadd__(self, arg0: Range2d) -> Range2d:
        ...
    def __imul__(self, arg0: float) -> Range2d:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Range2d) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec2d, arg1: Vec2d) -> None:
        ...
    def __isub__(self, arg0: Range2d) -> Range2d:
        ...
    def __itruediv__(self, arg0: float) -> Range2d:
        ...
    def __mul__(self, arg0: float) -> Range2d:
        ...
    def __ne__(self, arg0: Range2d) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: float) -> Range2d:
        ...
    def __str__(self) -> str:
        ...
    def __sub__(self, arg0: Range2d) -> Range2d:
        ...
    def __truediv__(self, arg0: float) -> Range2d:
        ...
class Range2f:
    __hash__: typing.ClassVar[None] = None
    max: Vec2f
    min: Vec2f
    @staticmethod
    def GetIntersection(arg0: Range2f, arg1: Range2f) -> Range2f:
        ...
    @staticmethod
    def GetUnion(arg0: Range2f, arg1: Range2f) -> Range2f:
        ...
    @staticmethod
    def unitSquare() -> Range2f:
        ...
    @typing.overload
    def Contains(self, arg0: Vec2f) -> bool:
        ...
    @typing.overload
    def Contains(self, arg0: Range2f) -> bool:
        ...
    def GetCorner(self, arg0: int) -> Vec2f:
        ...
    def GetDistanceSquared(self, arg0: Vec2f) -> float:
        ...
    def GetMax(self) -> Vec2f:
        ...
    def GetMidpoint(self) -> Vec2f:
        ...
    def GetMin(self) -> Vec2f:
        ...
    def GetQuadrant(self, arg0: int) -> Range2f:
        ...
    def GetSize(self) -> Vec2f:
        ...
    def IntersectWith(self, arg0: Range2f) -> Range2f:
        ...
    def IsEmpty(self) -> bool:
        ...
    def SetEmpty(self) -> None:
        ...
    def SetMax(self, arg0: Vec2f) -> None:
        ...
    def SetMin(self, arg0: Vec2f) -> None:
        ...
    @typing.overload
    def UnionWith(self, arg0: Vec2f) -> Range2f:
        ...
    @typing.overload
    def UnionWith(self, arg0: Range2f) -> Range2f:
        ...
    def __add__(self, arg0: Range2f) -> Range2f:
        ...
    def __copy__(self) -> Range2f:
        ...
    def __deepcopy__(self, memo: dict) -> Range2f:
        ...
    def __eq__(self, arg0: Range2f) -> bool:
        ...
    def __iadd__(self, arg0: Range2f) -> Range2f:
        ...
    def __imul__(self, arg0: float) -> Range2f:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Range2f) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec2f, arg1: Vec2f) -> None:
        ...
    def __isub__(self, arg0: Range2f) -> Range2f:
        ...
    def __itruediv__(self, arg0: float) -> Range2f:
        ...
    def __mul__(self, arg0: float) -> Range2f:
        ...
    def __ne__(self, arg0: Range2f) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: float) -> Range2f:
        ...
    def __str__(self) -> str:
        ...
    def __sub__(self, arg0: Range2f) -> Range2f:
        ...
    def __truediv__(self, arg0: float) -> Range2f:
        ...
class Range3d:
    __hash__: typing.ClassVar[None] = None
    max: Vec3d
    min: Vec3d
    @staticmethod
    def GetIntersection(arg0: Range3d, arg1: Range3d) -> Range3d:
        ...
    @staticmethod
    def GetUnion(arg0: Range3d, arg1: Range3d) -> Range3d:
        ...
    @staticmethod
    def unitCube() -> Range3d:
        ...
    @typing.overload
    def Contains(self, arg0: Vec3d) -> bool:
        ...
    @typing.overload
    def Contains(self, arg0: Range3d) -> bool:
        ...
    def GetCorner(self, arg0: int) -> Vec3d:
        ...
    def GetDistanceSquared(self, arg0: Vec3d) -> float:
        ...
    def GetMax(self) -> Vec3d:
        ...
    def GetMidpoint(self) -> Vec3d:
        ...
    def GetMin(self) -> Vec3d:
        ...
    def GetOctant(self, arg0: int) -> Range3d:
        ...
    def GetSize(self) -> Vec3d:
        ...
    def IntersectWith(self, arg0: Range3d) -> Range3d:
        ...
    def IsEmpty(self) -> bool:
        ...
    def SetEmpty(self) -> None:
        ...
    def SetMax(self, arg0: Vec3d) -> None:
        ...
    def SetMin(self, arg0: Vec3d) -> None:
        ...
    @typing.overload
    def UnionWith(self, arg0: Vec3d) -> Range3d:
        ...
    @typing.overload
    def UnionWith(self, arg0: Range3d) -> Range3d:
        ...
    def __add__(self, arg0: Range3d) -> Range3d:
        ...
    def __copy__(self) -> Range3d:
        ...
    def __deepcopy__(self, memo: dict) -> Range3d:
        ...
    def __eq__(self, arg0: Range3d) -> bool:
        ...
    def __iadd__(self, arg0: Range3d) -> Range3d:
        ...
    def __imul__(self, arg0: float) -> Range3d:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Range3d) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec3d, arg1: Vec3d) -> None:
        ...
    def __isub__(self, arg0: Range3d) -> Range3d:
        ...
    def __itruediv__(self, arg0: float) -> Range3d:
        ...
    def __mul__(self, arg0: float) -> Range3d:
        ...
    def __ne__(self, arg0: Range3d) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: float) -> Range3d:
        ...
    def __str__(self) -> str:
        ...
    def __sub__(self, arg0: Range3d) -> Range3d:
        ...
    def __truediv__(self, arg0: float) -> Range3d:
        ...
class Range3f:
    __hash__: typing.ClassVar[None] = None
    max: Vec3f
    min: Vec3f
    @staticmethod
    def GetIntersection(arg0: Range3f, arg1: Range3f) -> Range3f:
        ...
    @staticmethod
    def GetUnion(arg0: Range3f, arg1: Range3f) -> Range3f:
        ...
    @staticmethod
    def unitCube() -> Range3f:
        ...
    @typing.overload
    def Contains(self, arg0: Vec3f) -> bool:
        ...
    @typing.overload
    def Contains(self, arg0: Range3f) -> bool:
        ...
    def GetCorner(self, arg0: int) -> Vec3f:
        ...
    def GetDistanceSquared(self, arg0: Vec3f) -> float:
        ...
    def GetMax(self) -> Vec3f:
        ...
    def GetMidpoint(self) -> Vec3f:
        ...
    def GetMin(self) -> Vec3f:
        ...
    def GetOctant(self, arg0: int) -> Range3f:
        ...
    def GetSize(self) -> Vec3f:
        ...
    def IntersectWith(self, arg0: Range3f) -> Range3f:
        ...
    def IsEmpty(self) -> bool:
        ...
    def SetEmpty(self) -> None:
        ...
    def SetMax(self, arg0: Vec3f) -> None:
        ...
    def SetMin(self, arg0: Vec3f) -> None:
        ...
    @typing.overload
    def UnionWith(self, arg0: Vec3f) -> Range3f:
        ...
    @typing.overload
    def UnionWith(self, arg0: Range3f) -> Range3f:
        ...
    def __add__(self, arg0: Range3f) -> Range3f:
        ...
    def __copy__(self) -> Range3f:
        ...
    def __deepcopy__(self, memo: dict) -> Range3f:
        ...
    def __eq__(self, arg0: Range3f) -> bool:
        ...
    def __iadd__(self, arg0: Range3f) -> Range3f:
        ...
    def __imul__(self, arg0: float) -> Range3f:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Range3f) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec3f, arg1: Vec3f) -> None:
        ...
    def __isub__(self, arg0: Range3f) -> Range3f:
        ...
    def __itruediv__(self, arg0: float) -> Range3f:
        ...
    def __mul__(self, arg0: float) -> Range3f:
        ...
    def __ne__(self, arg0: Range3f) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: float) -> Range3f:
        ...
    def __str__(self) -> str:
        ...
    def __sub__(self, arg0: Range3f) -> Range3f:
        ...
    def __truediv__(self, arg0: float) -> Range3f:
        ...
class Ray:
    """
    """
    __hash__: typing.ClassVar[None] = None
    direction: Vec3d
    startPoint: Vec3d
    def FindClosestPoint(self, point: Vec3d) -> tuple:
        ...
    def GetPoint(self, arg0: float) -> Vec3d:
        ...
    @typing.overload
    def Intersect(self, p0: Vec3d, p1: Vec3d, p2: Vec3d) -> tuple:
        ...
    @typing.overload
    def Intersect(self, plane: ...) -> tuple:
        ...
    @typing.overload
    def Intersect(self, box: Range3d) -> tuple:
        ...
    @typing.overload
    def Intersect(self, box: ...) -> tuple:
        ...
    @typing.overload
    def Intersect(self, center: Vec3d, radius: float) -> tuple:
        ...
    @typing.overload
    def Intersect(self, origin: Vec3d, axis: Vec3d, radius: float) -> tuple:
        ...
    @typing.overload
    def Intersect(self, origin: Vec3d, axis: Vec3d, radius: float, height: float) -> tuple:
        ...
    def SetEnds(self, startPoint: Vec3d, endPoint: Vec3d) -> Ray:
        ...
    def SetPointAndDirection(self, startPoint: Vec3d, direction: Vec3d) -> Ray:
        ...
    def Transform(self, matrix: Matrix4d) -> Ray:
        ...
    def __eq__(self, arg0: Ray) -> bool:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, startPoint: Vec3d, direction: Vec3d) -> None:
        ...
    def __ne__(self, arg0: Ray) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
class Rect2i:
    __hash__: typing.ClassVar[None] = None
    max: Vec2i
    maxX: int
    maxY: int
    min: Vec2i
    minX: int
    minY: int
    def Contains(self, arg0: Vec2i) -> bool:
        ...
    def GetArea(self) -> int:
        ...
    def GetCenter(self) -> Vec2i:
        ...
    def GetHeight(self) -> int:
        ...
    def GetIntersection(self, arg0: Rect2i) -> Rect2i:
        ...
    def GetMax(self) -> Vec2i:
        ...
    def GetMaxX(self) -> int:
        ...
    def GetMaxY(self) -> int:
        ...
    def GetMin(self) -> Vec2i:
        ...
    def GetMinX(self) -> int:
        ...
    def GetMinY(self) -> int:
        ...
    def GetNormalized(self) -> Rect2i:
        ...
    def GetSize(self) -> Vec2i:
        ...
    def GetUnion(self, arg0: Rect2i) -> Rect2i:
        ...
    def GetWidth(self) -> int:
        ...
    def Intersect(self, arg0: Rect2i) -> Rect2i:
        ...
    def IsEmpty(self) -> bool:
        ...
    def IsNull(self) -> bool:
        ...
    def IsValid(self) -> bool:
        ...
    def SetMax(self, arg0: Vec2i) -> None:
        ...
    def SetMaxX(self, arg0: int) -> None:
        ...
    def SetMaxY(self, arg0: int) -> None:
        ...
    def SetMin(self, arg0: Vec2i) -> None:
        ...
    def SetMinX(self, arg0: int) -> None:
        ...
    def SetMinY(self, arg0: int) -> None:
        ...
    def Translate(self, arg0: Vec2i) -> None:
        ...
    def Union(self, arg0: Rect2i) -> Rect2i:
        ...
    def __add__(self, arg0: Rect2i) -> Rect2i:
        ...
    def __copy__(self) -> Rect2i:
        ...
    def __deepcopy__(self, memo: dict) -> Rect2i:
        ...
    def __eq__(self, arg0: Rect2i) -> bool:
        ...
    def __iadd__(self, arg0: Rect2i) -> Rect2i:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Rect2i) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec2i, arg1: Vec2i) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec2i, arg1: int, arg2: int) -> None:
        ...
    def __ne__(self, arg0: Rect2i) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    @property
    def area(self) -> int:
        ...
    @property
    def center(self) -> Vec2i:
        ...
    @property
    def height(self) -> int:
        ...
    @property
    def size(self) -> Vec2i:
        ...
    @property
    def width(self) -> int:
        ...
class Rotation:
    __hash__: typing.ClassVar[None] = None
    angle: float
    axis: Vec3d
    @staticmethod
    def DecomposeRotation(rot: Matrix4d, twAxis: Vec3d, fbAxis: Vec3d, lrAxis: Vec3d, handedness: float, thetaTwHint: typing.Any = None, thetaFBHint: typing.Any = None, thetaLRHint: typing.Any = None, thetaSwHint: typing.Any = None, useHint: bool = False, swShift: typing.Any = None) -> tuple[float, float, float, float]:
        ...
    @staticmethod
    def DecomposeRotation3(rot: Matrix4d, twAxis: Vec3d, fbAxis: Vec3d, lrAxis: Vec3d, handedness: float, thetaTwHint: float = 0.0, thetaFBHint: float = 0.0, thetaLRHint: float = 0.0, useHint: bool = False) -> tuple[float, float, float]:
        ...
    @staticmethod
    def RotateOntoProjected(arg0: Vec3d, arg1: Vec3d, arg2: Vec3d) -> Rotation:
        ...
    def Decompose(self, arg0: Vec3d, arg1: Vec3d, arg2: Vec3d) -> Vec3d:
        ...
    def GetAngle(self) -> float:
        ...
    def GetAxis(self) -> Vec3d:
        ...
    def GetInverse(self) -> Rotation:
        ...
    def GetQuat(self) -> Quatd:
        ...
    def SetAxisAngle(self, axis: Vec3d, angle: float) -> Rotation:
        ...
    def SetIdentity(self) -> Rotation:
        ...
    def SetQuat(self, quat: Quatd) -> Rotation:
        ...
    def SetRotateInto(self, rotateFrom: Vec3d, rotateTo: Vec3d) -> Rotation:
        ...
    @typing.overload
    def TransformDir(self, arg0: Vec3f) -> Vec3f:
        ...
    @typing.overload
    def TransformDir(self, arg0: Vec3d) -> Vec3d:
        ...
    def __eq__(self, arg0: Rotation) -> bool:
        ...
    @typing.overload
    def __imul__(self, arg0: Rotation) -> Rotation:
        ...
    @typing.overload
    def __imul__(self, arg0: float) -> Rotation:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec3d, arg1: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Quatd) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec3d, arg1: Vec3d) -> None:
        ...
    def __itruediv__(self, arg0: float) -> Rotation:
        ...
    @typing.overload
    def __mul__(self, arg0: Rotation) -> Rotation:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> Rotation:
        ...
    def __ne__(self, arg0: Rotation) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: float) -> Rotation:
        ...
    def __str__(self) -> str:
        ...
    def __truediv__(self, arg0: float) -> Rotation:
        ...
class Transform:
    __hash__: typing.ClassVar[None] = None
    pivotOrientation: Rotation
    pivotPosition: Vec3d
    rotation: Rotation
    scale: Vec3d
    translation: Vec3d
    def GetMatrix(self) -> Matrix4d:
        ...
    def GetPivotOrientation(self) -> Rotation:
        ...
    def GetPivotPosition(self) -> Vec3d:
        ...
    def GetRotation(self) -> Rotation:
        ...
    def GetScale(self) -> Vec3d:
        ...
    def GetTranslation(self) -> Vec3d:
        ...
    def Set(self, translation: Vec3d = ..., rotation: Rotation = ..., scale: Vec3d = ..., pivotPosition: Vec3d = ..., pivotOrientation: Rotation = ...) -> Transform:
        ...
    def SetIdentity(self) -> Transform:
        ...
    def SetMatrix(self, matrix: Matrix4d) -> Transform:
        ...
    def SetPivotOrientation(self, pivotOrient: Rotation) -> None:
        ...
    def SetPivotPosition(self, pivotPosition: Vec3d) -> None:
        ...
    def SetRotation(self, rotation: Rotation) -> None:
        ...
    def SetScale(self, scale: Vec3d) -> None:
        ...
    def SetTranslation(self, translation: Vec3d) -> None:
        ...
    def __eq__(self, arg0: Transform) -> bool:
        ...
    def __imul__(self, arg0: Transform) -> Transform:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, translation: Vec3d = ..., rotation: Rotation = ..., scale: Vec3d = ..., pivotPosition: Vec3d = ..., pivotOrientation: Rotation = ...) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Matrix4d) -> None:
        ...
    def __mul__(self, arg0: Transform) -> Transform:
        ...
    def __ne__(self, arg0: Transform) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
class Vec2d:
    __hash__: typing.ClassVar[None] = None
    __isGfVec: typing.ClassVar[bool] = True
    dimension: typing.ClassVar[int] = 2
    @staticmethod
    def Axis(arg0: int) -> Vec2d:
        ...
    @staticmethod
    def XAxis() -> Vec2d:
        ...
    @staticmethod
    def YAxis() -> Vec2d:
        ...
    def GetComplement(self, arg0: Vec2d) -> Vec2d:
        ...
    def GetDot(self, arg0: Vec2d) -> float:
        ...
    def GetLength(self) -> float:
        ...
    def GetNormalized(self) -> Vec2d:
        ...
    def GetProjection(self, arg0: Vec2d) -> Vec2d:
        ...
    def Normalize(self) -> float:
        ...
    def __add__(self, arg0: Vec2d) -> Vec2d:
        ...
    def __copy__(self) -> Vec2d:
        ...
    def __deepcopy__(self, memo: dict) -> Vec2d:
        ...
    @typing.overload
    def __eq__(self, arg0: Vec2d) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: Vec2f) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: ...) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: ...) -> bool:
        ...
    @typing.overload
    def __getitem__(self, arg0: int) -> float:
        ...
    @typing.overload
    def __getitem__(self, arg0: slice) -> list[float]:
        ...
    def __iadd__(self, arg0: Vec2d) -> Vec2d:
        ...
    def __imul__(self, arg0: float) -> Vec2d:
        ...
    @typing.overload
    def __init__(self, arg0: ...) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec2f) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec2d) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: ...) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: tuple[float, float]) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing_extensions.Buffer) -> None:
        ...
    def __isub__(self, arg0: Vec2d) -> Vec2d:
        ...
    def __itruediv__(self, arg0: float) -> Vec2d:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> Vec2d:
        ...
    @typing.overload
    def __mul__(self, arg0: Vec2d) -> float:
        ...
    @typing.overload
    def __ne__(self, arg0: Vec2d) -> bool:
        ...
    @typing.overload
    def __ne__(self, arg0: Vec2f) -> bool:
        ...
    @typing.overload
    def __ne__(self, arg0: ...) -> bool:
        ...
    @typing.overload
    def __ne__(self, arg0: ...) -> bool:
        ...
    def __neg__(self) -> Vec2d:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: float) -> Vec2d:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: float) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: typing.Sequence) -> None:
        ...
    def __str__(self) -> str:
        ...
    def __sub__(self, arg0: Vec2d) -> Vec2d:
        ...
    def __truediv__(self, arg0: float) -> Vec2d:
        ...
class Vec2f:
    __hash__: typing.ClassVar[None] = None
    __isGfVec: typing.ClassVar[bool] = True
    dimension: typing.ClassVar[int] = 2
    @staticmethod
    def Axis(arg0: int) -> Vec2f:
        ...
    @staticmethod
    def XAxis() -> Vec2f:
        ...
    @staticmethod
    def YAxis() -> Vec2f:
        ...
    def GetComplement(self, arg0: Vec2f) -> Vec2f:
        ...
    def GetDot(self, arg0: Vec2f) -> float:
        ...
    def GetLength(self) -> float:
        ...
    def GetNormalized(self) -> Vec2f:
        ...
    def GetProjection(self, arg0: Vec2f) -> Vec2f:
        ...
    def Normalize(self) -> float:
        ...
    def __add__(self, arg0: Vec2f) -> Vec2f:
        ...
    def __copy__(self) -> Vec2f:
        ...
    def __deepcopy__(self, memo: dict) -> Vec2f:
        ...
    @typing.overload
    def __eq__(self, arg0: Vec2f) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: ...) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: ...) -> bool:
        ...
    @typing.overload
    def __getitem__(self, arg0: int) -> float:
        ...
    @typing.overload
    def __getitem__(self, arg0: slice) -> list[float]:
        ...
    def __iadd__(self, arg0: Vec2f) -> Vec2f:
        ...
    def __imul__(self, arg0: float) -> Vec2f:
        ...
    @typing.overload
    def __init__(self, arg0: ...) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec2f) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: ...) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: ...) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: tuple[float, float]) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing_extensions.Buffer) -> None:
        ...
    def __isub__(self, arg0: Vec2f) -> Vec2f:
        ...
    def __itruediv__(self, arg0: float) -> Vec2f:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> Vec2f:
        ...
    @typing.overload
    def __mul__(self, arg0: Vec2f) -> float:
        ...
    @typing.overload
    def __ne__(self, arg0: Vec2f) -> bool:
        ...
    @typing.overload
    def __ne__(self, arg0: ...) -> bool:
        ...
    @typing.overload
    def __ne__(self, arg0: ...) -> bool:
        ...
    def __neg__(self) -> Vec2f:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: float) -> Vec2f:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: float) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: typing.Sequence) -> None:
        ...
    def __str__(self) -> str:
        ...
    def __sub__(self, arg0: Vec2f) -> Vec2f:
        ...
    def __truediv__(self, arg0: float) -> Vec2f:
        ...
class Vec2h:
    __hash__: typing.ClassVar[None] = None
    __isGfVec: typing.ClassVar[bool] = True
    dimension: typing.ClassVar[int] = 2
    @staticmethod
    def Axis(arg0: int) -> Vec2h:
        ...
    @staticmethod
    def XAxis() -> Vec2h:
        ...
    @staticmethod
    def YAxis() -> Vec2h:
        ...
    def GetComplement(self, arg0: Vec2h) -> Vec2h:
        ...
    def GetDot(self, arg0: Vec2h) -> GfHalf:
        ...
    def GetLength(self) -> float:
        ...
    def GetNormalized(self) -> Vec2h:
        ...
    def GetProjection(self, arg0: Vec2h) -> Vec2h:
        ...
    def Normalize(self) -> float:
        ...
    def __add__(self, arg0: Vec2h) -> Vec2h:
        ...
    def __copy__(self) -> Vec2h:
        ...
    def __deepcopy__(self, memo: dict) -> Vec2h:
        ...
    @typing.overload
    def __eq__(self, arg0: Vec2h) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: Vec2i) -> bool:
        ...
    @typing.overload
    def __getitem__(self, arg0: int) -> GfHalf:
        ...
    @typing.overload
    def __getitem__(self, arg0: slice) -> list[GfHalf]:
        ...
    def __iadd__(self, arg0: Vec2h) -> Vec2h:
        ...
    def __imul__(self, arg0: GfHalf) -> Vec2h:
        ...
    @typing.overload
    def __init__(self, arg0: Vec2i) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec2f) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec2d) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec2h) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: GfHalf, arg1: GfHalf) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: tuple[GfHalf, GfHalf]) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: GfHalf) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing_extensions.Buffer) -> None:
        ...
    def __isub__(self, arg0: Vec2h) -> Vec2h:
        ...
    def __itruediv__(self, arg0: GfHalf) -> Vec2h:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: GfHalf) -> Vec2h:
        ...
    @typing.overload
    def __mul__(self, arg0: Vec2h) -> GfHalf:
        ...
    @typing.overload
    def __ne__(self, arg0: Vec2h) -> bool:
        ...
    @typing.overload
    def __ne__(self, arg0: Vec2i) -> bool:
        ...
    def __neg__(self) -> Vec2h:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: GfHalf) -> Vec2h:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: GfHalf) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: typing.Sequence) -> None:
        ...
    def __str__(self) -> str:
        ...
    def __sub__(self, arg0: Vec2h) -> Vec2h:
        ...
    def __truediv__(self, arg0: GfHalf) -> Vec2h:
        ...
class Vec2i:
    __hash__: typing.ClassVar[None] = None
    __isGfVec: typing.ClassVar[bool] = True
    dimension: typing.ClassVar[int] = 2
    @staticmethod
    def Axis(arg0: int) -> Vec2i:
        ...
    @staticmethod
    def XAxis() -> Vec2i:
        ...
    @staticmethod
    def YAxis() -> Vec2i:
        ...
    def GetComplement(self, arg0: Vec2i) -> Vec2i:
        ...
    def GetDot(self, arg0: Vec2i) -> int:
        ...
    def GetLength(self) -> float:
        ...
    def GetNormalized(self) -> Vec2i:
        ...
    def GetProjection(self, arg0: Vec2i) -> Vec2i:
        ...
    def Normalize(self) -> float:
        ...
    def __add__(self, arg0: Vec2i) -> Vec2i:
        ...
    def __copy__(self) -> Vec2i:
        ...
    def __deepcopy__(self, memo: dict) -> Vec2i:
        ...
    def __eq__(self, arg0: Vec2i) -> bool:
        ...
    @typing.overload
    def __getitem__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __getitem__(self, arg0: slice) -> list[int]:
        ...
    def __iadd__(self, arg0: Vec2i) -> Vec2i:
        ...
    def __imul__(self, arg0: int) -> Vec2i:
        ...
    @typing.overload
    def __init__(self, arg0: Vec2i) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec2f) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec2d) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: ...) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int, arg1: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: tuple[int, int]) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing_extensions.Buffer) -> None:
        ...
    def __isub__(self, arg0: Vec2i) -> Vec2i:
        ...
    def __itruediv__(self, arg0: int) -> Vec2i:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> Vec2i:
        ...
    @typing.overload
    def __mul__(self, arg0: Vec2i) -> int:
        ...
    def __ne__(self, arg0: Vec2i) -> bool:
        ...
    def __neg__(self) -> Vec2i:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: int) -> Vec2i:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: int) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: typing.Sequence) -> None:
        ...
    def __str__(self) -> str:
        ...
    def __sub__(self, arg0: Vec2i) -> Vec2i:
        ...
    def __truediv__(self, arg0: int) -> Vec2i:
        ...
class Vec3d:
    __hash__: typing.ClassVar[None] = None
    __isGfVec: typing.ClassVar[bool] = True
    dimension: typing.ClassVar[int] = 3
    @staticmethod
    def Axis(arg0: int) -> Vec3d:
        ...
    @staticmethod
    def OrthogonalizeBasis(v1: Vec3d, v2: Vec3d, v3: Vec3d, normalize: bool = True) -> bool:
        ...
    @staticmethod
    def XAxis() -> Vec3d:
        ...
    @staticmethod
    def YAxis() -> Vec3d:
        ...
    @staticmethod
    def ZAxis() -> Vec3d:
        ...
    def BuildOrthonormalFrame(self, eps: float = 1e-10) -> tuple:
        ...
    def GetComplement(self, arg0: Vec3d) -> Vec3d:
        ...
    def GetCross(self, arg0: Vec3d) -> Vec3d:
        ...
    def GetDot(self, arg0: Vec3d) -> float:
        ...
    def GetLength(self) -> float:
        ...
    def GetNormalized(self) -> Vec3d:
        ...
    def GetProjection(self, arg0: Vec3d) -> Vec3d:
        ...
    def Normalize(self) -> float:
        ...
    def __add__(self, arg0: Vec3d) -> Vec3d:
        ...
    def __copy__(self) -> Vec3d:
        ...
    def __deepcopy__(self, memo: dict) -> Vec3d:
        ...
    @typing.overload
    def __eq__(self, arg0: Vec3d) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: Vec3f) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: ...) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: ...) -> bool:
        ...
    @typing.overload
    def __getitem__(self, arg0: int) -> float:
        ...
    @typing.overload
    def __getitem__(self, arg0: slice) -> list[float]:
        ...
    def __iadd__(self, arg0: Vec3d) -> Vec3d:
        ...
    def __imul__(self, arg0: float) -> Vec3d:
        ...
    @typing.overload
    def __init__(self, arg0: ...) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec3f) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec3d) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: ...) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float, arg2: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: tuple[float, float, float]) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing_extensions.Buffer) -> None:
        ...
    def __isub__(self, arg0: Vec3d) -> Vec3d:
        ...
    def __itruediv__(self, arg0: float) -> Vec3d:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> Vec3d:
        ...
    @typing.overload
    def __mul__(self, arg0: Vec3d) -> float:
        ...
    @typing.overload
    def __ne__(self, arg0: Vec3d) -> bool:
        ...
    @typing.overload
    def __ne__(self, arg0: Vec3f) -> bool:
        ...
    @typing.overload
    def __ne__(self, arg0: ...) -> bool:
        ...
    @typing.overload
    def __ne__(self, arg0: ...) -> bool:
        ...
    def __neg__(self) -> Vec3d:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: float) -> Vec3d:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: float) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: typing.Sequence) -> None:
        ...
    def __str__(self) -> str:
        ...
    def __sub__(self, arg0: Vec3d) -> Vec3d:
        ...
    def __truediv__(self, arg0: float) -> Vec3d:
        ...
    def __xor__(self, arg0: Vec3d) -> Vec3d:
        ...
class Vec3f:
    __hash__: typing.ClassVar[None] = None
    __isGfVec: typing.ClassVar[bool] = True
    dimension: typing.ClassVar[int] = 3
    @staticmethod
    def Axis(arg0: int) -> Vec3f:
        ...
    @staticmethod
    def OrthogonalizeBasis(v1: Vec3f, v2: Vec3f, v3: Vec3f, normalize: bool = True) -> bool:
        ...
    @staticmethod
    def XAxis() -> Vec3f:
        ...
    @staticmethod
    def YAxis() -> Vec3f:
        ...
    @staticmethod
    def ZAxis() -> Vec3f:
        ...
    def BuildOrthonormalFrame(self, eps: float = 1e-10) -> tuple:
        ...
    def GetComplement(self, arg0: Vec3f) -> Vec3f:
        ...
    def GetCross(self, arg0: Vec3f) -> Vec3f:
        ...
    def GetDot(self, arg0: Vec3f) -> float:
        ...
    def GetLength(self) -> float:
        ...
    def GetNormalized(self) -> Vec3f:
        ...
    def GetProjection(self, arg0: Vec3f) -> Vec3f:
        ...
    def Normalize(self) -> float:
        ...
    def __add__(self, arg0: Vec3f) -> Vec3f:
        ...
    def __copy__(self) -> Vec3f:
        ...
    def __deepcopy__(self, memo: dict) -> Vec3f:
        ...
    @typing.overload
    def __eq__(self, arg0: Vec3f) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: ...) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: ...) -> bool:
        ...
    @typing.overload
    def __getitem__(self, arg0: int) -> float:
        ...
    @typing.overload
    def __getitem__(self, arg0: slice) -> list[float]:
        ...
    def __iadd__(self, arg0: Vec3f) -> Vec3f:
        ...
    def __imul__(self, arg0: float) -> Vec3f:
        ...
    @typing.overload
    def __init__(self, arg0: ...) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec3f) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: ...) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: ...) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float, arg2: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: tuple[float, float, float]) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing_extensions.Buffer) -> None:
        ...
    def __isub__(self, arg0: Vec3f) -> Vec3f:
        ...
    def __itruediv__(self, arg0: float) -> Vec3f:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> Vec3f:
        ...
    @typing.overload
    def __mul__(self, arg0: Vec3f) -> float:
        ...
    @typing.overload
    def __ne__(self, arg0: Vec3f) -> bool:
        ...
    @typing.overload
    def __ne__(self, arg0: ...) -> bool:
        ...
    @typing.overload
    def __ne__(self, arg0: ...) -> bool:
        ...
    def __neg__(self) -> Vec3f:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: float) -> Vec3f:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: float) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: typing.Sequence) -> None:
        ...
    def __str__(self) -> str:
        ...
    def __sub__(self, arg0: Vec3f) -> Vec3f:
        ...
    def __truediv__(self, arg0: float) -> Vec3f:
        ...
    def __xor__(self, arg0: Vec3f) -> Vec3f:
        ...
class Vec3h:
    __hash__: typing.ClassVar[None] = None
    __isGfVec: typing.ClassVar[bool] = True
    dimension: typing.ClassVar[int] = 3
    @staticmethod
    def Axis(arg0: int) -> Vec3h:
        ...
    @staticmethod
    def OrthogonalizeBasis(v1: Vec3h, v2: Vec3h, v3: Vec3h, normalize: bool = True) -> bool:
        ...
    @staticmethod
    def XAxis() -> Vec3h:
        ...
    @staticmethod
    def YAxis() -> Vec3h:
        ...
    @staticmethod
    def ZAxis() -> Vec3h:
        ...
    def BuildOrthonormalFrame(self, eps: float = 1e-10) -> tuple:
        ...
    def GetComplement(self, arg0: Vec3h) -> Vec3h:
        ...
    def GetCross(self, arg0: Vec3h) -> Vec3h:
        ...
    def GetDot(self, arg0: Vec3h) -> GfHalf:
        ...
    def GetLength(self) -> float:
        ...
    def GetNormalized(self) -> Vec3h:
        ...
    def GetProjection(self, arg0: Vec3h) -> Vec3h:
        ...
    def Normalize(self) -> float:
        ...
    def __add__(self, arg0: Vec3h) -> Vec3h:
        ...
    def __copy__(self) -> Vec3h:
        ...
    def __deepcopy__(self, memo: dict) -> Vec3h:
        ...
    @typing.overload
    def __eq__(self, arg0: Vec3h) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: Vec3i) -> bool:
        ...
    @typing.overload
    def __getitem__(self, arg0: int) -> GfHalf:
        ...
    @typing.overload
    def __getitem__(self, arg0: slice) -> list[GfHalf]:
        ...
    def __iadd__(self, arg0: Vec3h) -> Vec3h:
        ...
    def __imul__(self, arg0: GfHalf) -> Vec3h:
        ...
    @typing.overload
    def __init__(self, arg0: Vec3i) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec3f) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec3d) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec3h) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: GfHalf, arg1: GfHalf, arg2: GfHalf) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: tuple[GfHalf, GfHalf, GfHalf]) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: GfHalf) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing_extensions.Buffer) -> None:
        ...
    def __isub__(self, arg0: Vec3h) -> Vec3h:
        ...
    def __itruediv__(self, arg0: GfHalf) -> Vec3h:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: GfHalf) -> Vec3h:
        ...
    @typing.overload
    def __mul__(self, arg0: Vec3h) -> GfHalf:
        ...
    @typing.overload
    def __ne__(self, arg0: Vec3h) -> bool:
        ...
    @typing.overload
    def __ne__(self, arg0: Vec3i) -> bool:
        ...
    def __neg__(self) -> Vec3h:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: GfHalf) -> Vec3h:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: GfHalf) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: typing.Sequence) -> None:
        ...
    def __str__(self) -> str:
        ...
    def __sub__(self, arg0: Vec3h) -> Vec3h:
        ...
    def __truediv__(self, arg0: GfHalf) -> Vec3h:
        ...
    def __xor__(self, arg0: Vec3h) -> Vec3h:
        ...
class Vec3i:
    __hash__: typing.ClassVar[None] = None
    __isGfVec: typing.ClassVar[bool] = True
    dimension: typing.ClassVar[int] = 3
    @staticmethod
    def Axis(arg0: int) -> Vec3i:
        ...
    @staticmethod
    def OrthogonalizeBasis(v1: Vec3i, v2: Vec3i, v3: Vec3i, normalize: bool = True) -> bool:
        ...
    @staticmethod
    def XAxis() -> Vec3i:
        ...
    @staticmethod
    def YAxis() -> Vec3i:
        ...
    @staticmethod
    def ZAxis() -> Vec3i:
        ...
    def BuildOrthonormalFrame(self, eps: float = 1e-10) -> tuple:
        ...
    def GetComplement(self, arg0: Vec3i) -> Vec3i:
        ...
    def GetCross(self, arg0: Vec3i) -> Vec3i:
        ...
    def GetDot(self, arg0: Vec3i) -> int:
        ...
    def GetLength(self) -> float:
        ...
    def GetNormalized(self) -> Vec3i:
        ...
    def GetProjection(self, arg0: Vec3i) -> Vec3i:
        ...
    def Normalize(self) -> float:
        ...
    def __add__(self, arg0: Vec3i) -> Vec3i:
        ...
    def __copy__(self) -> Vec3i:
        ...
    def __deepcopy__(self, memo: dict) -> Vec3i:
        ...
    def __eq__(self, arg0: Vec3i) -> bool:
        ...
    @typing.overload
    def __getitem__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __getitem__(self, arg0: slice) -> list[int]:
        ...
    def __iadd__(self, arg0: Vec3i) -> Vec3i:
        ...
    def __imul__(self, arg0: int) -> Vec3i:
        ...
    @typing.overload
    def __init__(self, arg0: Vec3i) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec3f) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec3d) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: ...) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int, arg1: int, arg2: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: tuple[int, int, int]) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing_extensions.Buffer) -> None:
        ...
    def __isub__(self, arg0: Vec3i) -> Vec3i:
        ...
    def __itruediv__(self, arg0: int) -> Vec3i:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> Vec3i:
        ...
    @typing.overload
    def __mul__(self, arg0: Vec3i) -> int:
        ...
    def __ne__(self, arg0: Vec3i) -> bool:
        ...
    def __neg__(self) -> Vec3i:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: int) -> Vec3i:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: int) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: typing.Sequence) -> None:
        ...
    def __str__(self) -> str:
        ...
    def __sub__(self, arg0: Vec3i) -> Vec3i:
        ...
    def __truediv__(self, arg0: int) -> Vec3i:
        ...
    def __xor__(self, arg0: Vec3i) -> Vec3i:
        ...
class Vec4d:
    __hash__: typing.ClassVar[None] = None
    __isGfVec: typing.ClassVar[bool] = True
    dimension: typing.ClassVar[int] = 4
    @staticmethod
    def Axis(arg0: int) -> Vec4d:
        ...
    @staticmethod
    def WAxis() -> Vec4d:
        ...
    @staticmethod
    def XAxis() -> Vec4d:
        ...
    @staticmethod
    def YAxis() -> Vec4d:
        ...
    @staticmethod
    def ZAxis() -> Vec4d:
        ...
    def GetComplement(self, arg0: Vec4d) -> Vec4d:
        ...
    def GetDot(self, arg0: Vec4d) -> float:
        ...
    def GetLength(self) -> float:
        ...
    def GetNormalized(self) -> Vec4d:
        ...
    def GetProjection(self, arg0: Vec4d) -> Vec4d:
        ...
    def Normalize(self) -> float:
        ...
    def __add__(self, arg0: Vec4d) -> Vec4d:
        ...
    def __copy__(self) -> Vec4d:
        ...
    def __deepcopy__(self, memo: dict) -> Vec4d:
        ...
    @typing.overload
    def __eq__(self, arg0: Vec4d) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: Vec4f) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: ...) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: ...) -> bool:
        ...
    @typing.overload
    def __getitem__(self, arg0: int) -> float:
        ...
    @typing.overload
    def __getitem__(self, arg0: slice) -> list[float]:
        ...
    def __iadd__(self, arg0: Vec4d) -> Vec4d:
        ...
    def __imul__(self, arg0: float) -> Vec4d:
        ...
    @typing.overload
    def __init__(self, arg0: ...) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec4f) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec4d) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: ...) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: tuple[float, float, float, float]) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing_extensions.Buffer) -> None:
        ...
    def __isub__(self, arg0: Vec4d) -> Vec4d:
        ...
    def __itruediv__(self, arg0: float) -> Vec4d:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> Vec4d:
        ...
    @typing.overload
    def __mul__(self, arg0: Vec4d) -> float:
        ...
    @typing.overload
    def __ne__(self, arg0: Vec4d) -> bool:
        ...
    @typing.overload
    def __ne__(self, arg0: Vec4f) -> bool:
        ...
    @typing.overload
    def __ne__(self, arg0: ...) -> bool:
        ...
    @typing.overload
    def __ne__(self, arg0: ...) -> bool:
        ...
    def __neg__(self) -> Vec4d:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: float) -> Vec4d:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: float) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: typing.Sequence) -> None:
        ...
    def __str__(self) -> str:
        ...
    def __sub__(self, arg0: Vec4d) -> Vec4d:
        ...
    def __truediv__(self, arg0: float) -> Vec4d:
        ...
class Vec4f:
    __hash__: typing.ClassVar[None] = None
    __isGfVec: typing.ClassVar[bool] = True
    dimension: typing.ClassVar[int] = 4
    @staticmethod
    def Axis(arg0: int) -> Vec4f:
        ...
    @staticmethod
    def WAxis() -> Vec4f:
        ...
    @staticmethod
    def XAxis() -> Vec4f:
        ...
    @staticmethod
    def YAxis() -> Vec4f:
        ...
    @staticmethod
    def ZAxis() -> Vec4f:
        ...
    def GetComplement(self, arg0: Vec4f) -> Vec4f:
        ...
    def GetDot(self, arg0: Vec4f) -> float:
        ...
    def GetLength(self) -> float:
        ...
    def GetNormalized(self) -> Vec4f:
        ...
    def GetProjection(self, arg0: Vec4f) -> Vec4f:
        ...
    def Normalize(self) -> float:
        ...
    def __add__(self, arg0: Vec4f) -> Vec4f:
        ...
    def __copy__(self) -> Vec4f:
        ...
    def __deepcopy__(self, memo: dict) -> Vec4f:
        ...
    @typing.overload
    def __eq__(self, arg0: Vec4f) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: ...) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: ...) -> bool:
        ...
    @typing.overload
    def __getitem__(self, arg0: int) -> float:
        ...
    @typing.overload
    def __getitem__(self, arg0: slice) -> list[float]:
        ...
    def __iadd__(self, arg0: Vec4f) -> Vec4f:
        ...
    def __imul__(self, arg0: float) -> Vec4f:
        ...
    @typing.overload
    def __init__(self, arg0: ...) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec4f) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: ...) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: ...) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: tuple[float, float, float, float]) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing_extensions.Buffer) -> None:
        ...
    def __isub__(self, arg0: Vec4f) -> Vec4f:
        ...
    def __itruediv__(self, arg0: float) -> Vec4f:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> Vec4f:
        ...
    @typing.overload
    def __mul__(self, arg0: Vec4f) -> float:
        ...
    @typing.overload
    def __ne__(self, arg0: Vec4f) -> bool:
        ...
    @typing.overload
    def __ne__(self, arg0: ...) -> bool:
        ...
    @typing.overload
    def __ne__(self, arg0: ...) -> bool:
        ...
    def __neg__(self) -> Vec4f:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: float) -> Vec4f:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: float) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: typing.Sequence) -> None:
        ...
    def __str__(self) -> str:
        ...
    def __sub__(self, arg0: Vec4f) -> Vec4f:
        ...
    def __truediv__(self, arg0: float) -> Vec4f:
        ...
class Vec4h:
    __hash__: typing.ClassVar[None] = None
    __isGfVec: typing.ClassVar[bool] = True
    dimension: typing.ClassVar[int] = 4
    @staticmethod
    def Axis(arg0: int) -> Vec4h:
        ...
    @staticmethod
    def WAxis() -> Vec4h:
        ...
    @staticmethod
    def XAxis() -> Vec4h:
        ...
    @staticmethod
    def YAxis() -> Vec4h:
        ...
    @staticmethod
    def ZAxis() -> Vec4h:
        ...
    def GetComplement(self, arg0: Vec4h) -> Vec4h:
        ...
    def GetDot(self, arg0: Vec4h) -> GfHalf:
        ...
    def GetLength(self) -> float:
        ...
    def GetNormalized(self) -> Vec4h:
        ...
    def GetProjection(self, arg0: Vec4h) -> Vec4h:
        ...
    def Normalize(self) -> float:
        ...
    def __add__(self, arg0: Vec4h) -> Vec4h:
        ...
    def __copy__(self) -> Vec4h:
        ...
    def __deepcopy__(self, memo: dict) -> Vec4h:
        ...
    @typing.overload
    def __eq__(self, arg0: Vec4h) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: Vec4i) -> bool:
        ...
    @typing.overload
    def __getitem__(self, arg0: int) -> GfHalf:
        ...
    @typing.overload
    def __getitem__(self, arg0: slice) -> list[GfHalf]:
        ...
    def __iadd__(self, arg0: Vec4h) -> Vec4h:
        ...
    def __imul__(self, arg0: GfHalf) -> Vec4h:
        ...
    @typing.overload
    def __init__(self, arg0: Vec4i) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec4f) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec4d) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec4h) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: GfHalf, arg1: GfHalf, arg2: GfHalf, arg3: GfHalf) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: tuple[GfHalf, GfHalf, GfHalf, GfHalf]) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: GfHalf) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing_extensions.Buffer) -> None:
        ...
    def __isub__(self, arg0: Vec4h) -> Vec4h:
        ...
    def __itruediv__(self, arg0: GfHalf) -> Vec4h:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: GfHalf) -> Vec4h:
        ...
    @typing.overload
    def __mul__(self, arg0: Vec4h) -> GfHalf:
        ...
    @typing.overload
    def __ne__(self, arg0: Vec4h) -> bool:
        ...
    @typing.overload
    def __ne__(self, arg0: Vec4i) -> bool:
        ...
    def __neg__(self) -> Vec4h:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: GfHalf) -> Vec4h:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: GfHalf) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: typing.Sequence) -> None:
        ...
    def __str__(self) -> str:
        ...
    def __sub__(self, arg0: Vec4h) -> Vec4h:
        ...
    def __truediv__(self, arg0: GfHalf) -> Vec4h:
        ...
class Vec4i:
    __hash__: typing.ClassVar[None] = None
    __isGfVec: typing.ClassVar[bool] = True
    dimension: typing.ClassVar[int] = 4
    @staticmethod
    def Axis(arg0: int) -> Vec4i:
        ...
    @staticmethod
    def WAxis() -> Vec4i:
        ...
    @staticmethod
    def XAxis() -> Vec4i:
        ...
    @staticmethod
    def YAxis() -> Vec4i:
        ...
    @staticmethod
    def ZAxis() -> Vec4i:
        ...
    def GetComplement(self, arg0: Vec4i) -> Vec4i:
        ...
    def GetDot(self, arg0: Vec4i) -> int:
        ...
    def GetLength(self) -> float:
        ...
    def GetNormalized(self) -> Vec4i:
        ...
    def GetProjection(self, arg0: Vec4i) -> Vec4i:
        ...
    def Normalize(self) -> float:
        ...
    def __add__(self, arg0: Vec4i) -> Vec4i:
        ...
    def __copy__(self) -> Vec4i:
        ...
    def __deepcopy__(self, memo: dict) -> Vec4i:
        ...
    def __eq__(self, arg0: Vec4i) -> bool:
        ...
    @typing.overload
    def __getitem__(self, arg0: int) -> int:
        ...
    @typing.overload
    def __getitem__(self, arg0: slice) -> list[int]:
        ...
    def __iadd__(self, arg0: Vec4i) -> Vec4i:
        ...
    def __imul__(self, arg0: int) -> Vec4i:
        ...
    @typing.overload
    def __init__(self, arg0: Vec4i) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec4f) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec4d) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: ...) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int, arg1: int, arg2: int, arg3: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: tuple[int, int, int, int]) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing_extensions.Buffer) -> None:
        ...
    def __isub__(self, arg0: Vec4i) -> Vec4i:
        ...
    def __itruediv__(self, arg0: int) -> Vec4i:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> Vec4i:
        ...
    @typing.overload
    def __mul__(self, arg0: Vec4i) -> int:
        ...
    def __ne__(self, arg0: Vec4i) -> bool:
        ...
    def __neg__(self) -> Vec4i:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: int) -> Vec4i:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: int) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: typing.Sequence) -> None:
        ...
    def __str__(self) -> str:
        ...
    def __sub__(self, arg0: Vec4i) -> Vec4i:
        ...
    def __truediv__(self, arg0: int) -> Vec4i:
        ...
def Abs(arg0: float) -> float:
    ...
def Absf(arg0: float) -> float:
    ...
@typing.overload
def Clamp(arg0: int, arg1: int, arg2: int) -> int:
    ...
@typing.overload
def Clamp(arg0: float, arg1: float, arg2: float) -> float:
    ...
def Clampf(arg0: float, arg1: float, arg2: float) -> float:
    ...
@typing.overload
def CompDiv(arg0: Vec2f, arg1: Vec2f) -> Vec2f:
    ...
@typing.overload
def CompDiv(arg0: Vec2d, arg1: Vec2d) -> Vec2d:
    ...
@typing.overload
def CompDiv(arg0: Vec2i, arg1: Vec2i) -> Vec2i:
    ...
@typing.overload
def CompDiv(arg0: Vec2h, arg1: Vec2h) -> Vec2h:
    ...
@typing.overload
def CompDiv(arg0: Vec3f, arg1: Vec3f) -> Vec3f:
    ...
@typing.overload
def CompDiv(arg0: Vec3d, arg1: Vec3d) -> Vec3d:
    ...
@typing.overload
def CompDiv(arg0: Vec3i, arg1: Vec3i) -> Vec3i:
    ...
@typing.overload
def CompDiv(arg0: Vec3h, arg1: Vec3h) -> Vec3h:
    ...
@typing.overload
def CompDiv(arg0: Vec4f, arg1: Vec4f) -> Vec4f:
    ...
@typing.overload
def CompDiv(arg0: Vec4d, arg1: Vec4d) -> Vec4d:
    ...
@typing.overload
def CompDiv(arg0: Vec4i, arg1: Vec4i) -> Vec4i:
    ...
@typing.overload
def CompDiv(arg0: Vec4h, arg1: Vec4h) -> Vec4h:
    ...
@typing.overload
def CompMult(arg0: Vec2f, arg1: Vec2f) -> Vec2f:
    ...
@typing.overload
def CompMult(arg0: Vec2d, arg1: Vec2d) -> Vec2d:
    ...
@typing.overload
def CompMult(arg0: Vec2i, arg1: Vec2i) -> Vec2i:
    ...
@typing.overload
def CompMult(arg0: Vec2h, arg1: Vec2h) -> Vec2h:
    ...
@typing.overload
def CompMult(arg0: Vec3f, arg1: Vec3f) -> Vec3f:
    ...
@typing.overload
def CompMult(arg0: Vec3d, arg1: Vec3d) -> Vec3d:
    ...
@typing.overload
def CompMult(arg0: Vec3i, arg1: Vec3i) -> Vec3i:
    ...
@typing.overload
def CompMult(arg0: Vec3h, arg1: Vec3h) -> Vec3h:
    ...
@typing.overload
def CompMult(arg0: Vec4f, arg1: Vec4f) -> Vec4f:
    ...
@typing.overload
def CompMult(arg0: Vec4d, arg1: Vec4d) -> Vec4d:
    ...
@typing.overload
def CompMult(arg0: Vec4i, arg1: Vec4i) -> Vec4i:
    ...
@typing.overload
def CompMult(arg0: Vec4h, arg1: Vec4h) -> Vec4h:
    ...
@typing.overload
def Cross(arg0: Vec3f, arg1: Vec3f) -> Vec3f:
    ...
@typing.overload
def Cross(arg0: Vec3d, arg1: Vec3d) -> Vec3d:
    ...
@typing.overload
def Cross(arg0: Vec3i, arg1: Vec3i) -> Vec3i:
    ...
@typing.overload
def Cross(arg0: Vec3h, arg1: Vec3h) -> Vec3h:
    ...
def DegreesToRadians(arg0: float) -> float:
    ...
@typing.overload
def Dot(arg0: Vec2f, arg1: Vec2f) -> float:
    ...
@typing.overload
def Dot(arg0: Vec2d, arg1: Vec2d) -> float:
    ...
@typing.overload
def Dot(arg0: Vec2i, arg1: Vec2i) -> int:
    ...
@typing.overload
def Dot(arg0: Vec2h, arg1: Vec2h) -> GfHalf:
    ...
@typing.overload
def Dot(arg0: Vec3f, arg1: Vec3f) -> float:
    ...
@typing.overload
def Dot(arg0: Vec3d, arg1: Vec3d) -> float:
    ...
@typing.overload
def Dot(arg0: Vec3i, arg1: Vec3i) -> int:
    ...
@typing.overload
def Dot(arg0: Vec3h, arg1: Vec3h) -> GfHalf:
    ...
@typing.overload
def Dot(arg0: Vec4f, arg1: Vec4f) -> float:
    ...
@typing.overload
def Dot(arg0: Vec4d, arg1: Vec4d) -> float:
    ...
@typing.overload
def Dot(arg0: Vec4i, arg1: Vec4i) -> int:
    ...
@typing.overload
def Dot(arg0: Vec4h, arg1: Vec4h) -> GfHalf:
    ...
@typing.overload
def Dot(arg0: Quatd, arg1: Quatd) -> float:
    ...
@typing.overload
def Dot(arg0: Quatf, arg1: Quatf) -> float:
    ...
@typing.overload
def Dot(arg0: Quath, arg1: Quath) -> GfHalf:
    ...
@typing.overload
def FindClosestPoints(l1: ..., l2: ...) -> tuple:
    ...
@typing.overload
def FindClosestPoints(l1: ..., l2: ...) -> tuple:
    ...
@typing.overload
def FindClosestPoints(l1: ..., l2: ...) -> tuple:
    ...
@typing.overload
def FindClosestPoints(l1: Line, l2: ...) -> tuple:
    ...
@typing.overload
def FindClosestPoints(l1: ..., l2: ...) -> tuple:
    ...
def FitPlaneToPoints(points: list[Vec3d]) -> typing.Any:
    ...
@typing.overload
def GetComplement(arg0: Vec2f, arg1: Vec2f) -> Vec2f:
    ...
@typing.overload
def GetComplement(arg0: Vec2d, arg1: Vec2d) -> Vec2d:
    ...
@typing.overload
def GetComplement(arg0: Vec2i, arg1: Vec2i) -> Vec2i:
    ...
@typing.overload
def GetComplement(arg0: Vec2h, arg1: Vec2h) -> Vec2h:
    ...
@typing.overload
def GetComplement(arg0: Vec3f, arg1: Vec3f) -> Vec3f:
    ...
@typing.overload
def GetComplement(arg0: Vec3d, arg1: Vec3d) -> Vec3d:
    ...
@typing.overload
def GetComplement(arg0: Vec3i, arg1: Vec3i) -> Vec3i:
    ...
@typing.overload
def GetComplement(arg0: Vec3h, arg1: Vec3h) -> Vec3h:
    ...
@typing.overload
def GetComplement(arg0: Vec4f, arg1: Vec4f) -> Vec4f:
    ...
@typing.overload
def GetComplement(arg0: Vec4d, arg1: Vec4d) -> Vec4d:
    ...
@typing.overload
def GetComplement(arg0: Vec4i, arg1: Vec4i) -> Vec4i:
    ...
@typing.overload
def GetComplement(arg0: Vec4h, arg1: Vec4h) -> Vec4h:
    ...
@typing.overload
def GetLength(arg0: Vec2f) -> float:
    ...
@typing.overload
def GetLength(arg0: Vec2d) -> float:
    ...
@typing.overload
def GetLength(arg0: Vec2i) -> float:
    ...
@typing.overload
def GetLength(arg0: Vec2h) -> float:
    ...
@typing.overload
def GetLength(arg0: Vec3f) -> float:
    ...
@typing.overload
def GetLength(arg0: Vec3d) -> float:
    ...
@typing.overload
def GetLength(arg0: Vec3i) -> float:
    ...
@typing.overload
def GetLength(arg0: Vec3h) -> float:
    ...
@typing.overload
def GetLength(arg0: Vec4f) -> float:
    ...
@typing.overload
def GetLength(arg0: Vec4d) -> float:
    ...
@typing.overload
def GetLength(arg0: Vec4i) -> float:
    ...
@typing.overload
def GetLength(arg0: Vec4h) -> float:
    ...
@typing.overload
def GetNormalized(arg0: Vec2f) -> Vec2f:
    ...
@typing.overload
def GetNormalized(arg0: Vec2d) -> Vec2d:
    ...
@typing.overload
def GetNormalized(arg0: Vec2i) -> Vec2i:
    ...
@typing.overload
def GetNormalized(arg0: Vec2h) -> Vec2h:
    ...
@typing.overload
def GetNormalized(arg0: Vec3f) -> Vec3f:
    ...
@typing.overload
def GetNormalized(arg0: Vec3d) -> Vec3d:
    ...
@typing.overload
def GetNormalized(arg0: Vec3i) -> Vec3i:
    ...
@typing.overload
def GetNormalized(arg0: Vec3h) -> Vec3h:
    ...
@typing.overload
def GetNormalized(arg0: Vec4f) -> Vec4f:
    ...
@typing.overload
def GetNormalized(arg0: Vec4d) -> Vec4d:
    ...
@typing.overload
def GetNormalized(arg0: Vec4i) -> Vec4i:
    ...
@typing.overload
def GetNormalized(arg0: Vec4h) -> Vec4h:
    ...
@typing.overload
def GetProjection(arg0: Vec2f, arg1: Vec2f) -> Vec2f:
    ...
@typing.overload
def GetProjection(arg0: Vec2d, arg1: Vec2d) -> Vec2d:
    ...
@typing.overload
def GetProjection(arg0: Vec2i, arg1: Vec2i) -> Vec2i:
    ...
@typing.overload
def GetProjection(arg0: Vec2h, arg1: Vec2h) -> Vec2h:
    ...
@typing.overload
def GetProjection(arg0: Vec3f, arg1: Vec3f) -> Vec3f:
    ...
@typing.overload
def GetProjection(arg0: Vec3d, arg1: Vec3d) -> Vec3d:
    ...
@typing.overload
def GetProjection(arg0: Vec3i, arg1: Vec3i) -> Vec3i:
    ...
@typing.overload
def GetProjection(arg0: Vec3h, arg1: Vec3h) -> Vec3h:
    ...
@typing.overload
def GetProjection(arg0: Vec4f, arg1: Vec4f) -> Vec4f:
    ...
@typing.overload
def GetProjection(arg0: Vec4d, arg1: Vec4d) -> Vec4d:
    ...
@typing.overload
def GetProjection(arg0: Vec4i, arg1: Vec4i) -> Vec4i:
    ...
@typing.overload
def GetProjection(arg0: Vec4h, arg1: Vec4h) -> Vec4h:
    ...
@typing.overload
def IsClose(arg0: float, arg1: float, arg2: float) -> bool:
    ...
@typing.overload
def IsClose(arg0: Vec2f, arg1: Vec2f, arg2: float) -> bool:
    ...
@typing.overload
def IsClose(arg0: Vec2d, arg1: Vec2d, arg2: float) -> bool:
    ...
@typing.overload
def IsClose(arg0: Vec2i, arg1: Vec2i, arg2: float) -> bool:
    ...
@typing.overload
def IsClose(arg0: Vec2h, arg1: Vec2h, arg2: float) -> bool:
    ...
@typing.overload
def IsClose(arg0: Vec3f, arg1: Vec3f, arg2: float) -> bool:
    ...
@typing.overload
def IsClose(arg0: Vec3d, arg1: Vec3d, arg2: float) -> bool:
    ...
@typing.overload
def IsClose(arg0: Vec3i, arg1: Vec3i, arg2: float) -> bool:
    ...
@typing.overload
def IsClose(arg0: Vec3h, arg1: Vec3h, arg2: float) -> bool:
    ...
@typing.overload
def IsClose(arg0: Vec4f, arg1: Vec4f, arg2: float) -> bool:
    ...
@typing.overload
def IsClose(arg0: Vec4d, arg1: Vec4d, arg2: float) -> bool:
    ...
@typing.overload
def IsClose(arg0: Vec4i, arg1: Vec4i, arg2: float) -> bool:
    ...
@typing.overload
def IsClose(arg0: Vec4h, arg1: Vec4h, arg2: float) -> bool:
    ...
@typing.overload
def IsClose(arg0: Matrix4d, arg1: Matrix4d, arg2: float) -> bool:
    ...
@typing.overload
def IsClose(arg0: Matrix4f, arg1: Matrix4f, arg2: float) -> bool:
    ...
@typing.overload
def IsClose(arg0: Quatd, arg1: Quatd, arg2: float) -> bool:
    ...
@typing.overload
def IsClose(arg0: Quatf, arg1: Quatf, arg2: float) -> bool:
    ...
@typing.overload
def IsClose(arg0: Quath, arg1: Quath, arg2: float) -> bool:
    ...
@typing.overload
def Lerp(alpha: float, a: float, b: float) -> float:
    ...
@typing.overload
def Lerp(alpha: float, a: Vec2f, b: Vec2f) -> Vec2f:
    ...
@typing.overload
def Lerp(alpha: float, a: Vec2d, b: Vec2d) -> Vec2d:
    ...
@typing.overload
def Lerp(alpha: float, a: Vec2i, b: Vec2i) -> Vec2i:
    ...
@typing.overload
def Lerp(alpha: float, a: Vec2h, b: Vec2h) -> Vec2h:
    ...
@typing.overload
def Lerp(alpha: float, a: Vec3f, b: Vec3f) -> Vec3f:
    ...
@typing.overload
def Lerp(alpha: float, a: Vec3d, b: Vec3d) -> Vec3d:
    ...
@typing.overload
def Lerp(alpha: float, a: Vec3i, b: Vec3i) -> Vec3i:
    ...
@typing.overload
def Lerp(alpha: float, a: Vec3h, b: Vec3h) -> Vec3h:
    ...
@typing.overload
def Lerp(alpha: float, a: Vec4f, b: Vec4f) -> Vec4f:
    ...
@typing.overload
def Lerp(alpha: float, a: Vec4d, b: Vec4d) -> Vec4d:
    ...
@typing.overload
def Lerp(alpha: float, a: Vec4i, b: Vec4i) -> Vec4i:
    ...
@typing.overload
def Lerp(alpha: float, a: Vec4h, b: Vec4h) -> Vec4h:
    ...
def Lerpf(alpha: float, a: float, b: float) -> float:
    ...
@typing.overload
def Max(arg0: float, arg1: float) -> float:
    ...
@typing.overload
def Max(arg0: float, arg1: float, arg2: float) -> float:
    ...
@typing.overload
def Max(arg0: float, arg1: float, arg2: float, arg3: float) -> float:
    ...
@typing.overload
def Max(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float) -> float:
    ...
@typing.overload
def Max(arg0: int, arg1: int) -> int:
    ...
@typing.overload
def Max(arg0: int, arg1: int, arg2: int) -> int:
    ...
@typing.overload
def Max(arg0: int, arg1: int, arg2: int, arg3: int) -> int:
    ...
@typing.overload
def Max(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int) -> int:
    ...
@typing.overload
def Min(arg0: float, arg1: float) -> float:
    ...
@typing.overload
def Min(arg0: float, arg1: float, arg2: float) -> float:
    ...
@typing.overload
def Min(arg0: float, arg1: float, arg2: float, arg3: float) -> float:
    ...
@typing.overload
def Min(arg0: float, arg1: float, arg2: float, arg3: float, arg4: float) -> float:
    ...
@typing.overload
def Min(arg0: int, arg1: int) -> int:
    ...
@typing.overload
def Min(arg0: int, arg1: int, arg2: int) -> int:
    ...
@typing.overload
def Min(arg0: int, arg1: int, arg2: int, arg3: int) -> int:
    ...
@typing.overload
def Min(arg0: int, arg1: int, arg2: int, arg3: int, arg4: int) -> int:
    ...
@typing.overload
def Normalize(arg0: Vec2f) -> float:
    ...
@typing.overload
def Normalize(arg0: Vec2d) -> float:
    ...
@typing.overload
def Normalize(arg0: Vec2i) -> float:
    ...
@typing.overload
def Normalize(arg0: Vec2h) -> float:
    ...
@typing.overload
def Normalize(arg0: Vec3f) -> float:
    ...
@typing.overload
def Normalize(arg0: Vec3d) -> float:
    ...
@typing.overload
def Normalize(arg0: Vec3i) -> float:
    ...
@typing.overload
def Normalize(arg0: Vec3h) -> float:
    ...
@typing.overload
def Normalize(arg0: Vec4f) -> float:
    ...
@typing.overload
def Normalize(arg0: Vec4d) -> float:
    ...
@typing.overload
def Normalize(arg0: Vec4i) -> float:
    ...
@typing.overload
def Normalize(arg0: Vec4h) -> float:
    ...
def RadiansToDegrees(arg0: float) -> float:
    ...
@typing.overload
def Slerp(alpha: float, v1: Vec2f, v2: Vec2f) -> Vec2f:
    ...
@typing.overload
def Slerp(alpha: float, v1: Vec2d, v2: Vec2d) -> Vec2d:
    ...
@typing.overload
def Slerp(alpha: float, v1: Vec2i, v2: Vec2i) -> Vec2i:
    ...
@typing.overload
def Slerp(alpha: float, v1: Vec2h, v2: Vec2h) -> Vec2h:
    ...
@typing.overload
def Slerp(alpha: float, v1: Vec3f, v2: Vec3f) -> Vec3f:
    ...
@typing.overload
def Slerp(alpha: float, v1: Vec3d, v2: Vec3d) -> Vec3d:
    ...
@typing.overload
def Slerp(alpha: float, v1: Vec3i, v2: Vec3i) -> Vec3i:
    ...
@typing.overload
def Slerp(alpha: float, v1: Vec3h, v2: Vec3h) -> Vec3h:
    ...
@typing.overload
def Slerp(alpha: float, v1: Vec4f, v2: Vec4f) -> Vec4f:
    ...
@typing.overload
def Slerp(alpha: float, v1: Vec4d, v2: Vec4d) -> Vec4d:
    ...
@typing.overload
def Slerp(alpha: float, v1: Vec4i, v2: Vec4i) -> Vec4i:
    ...
@typing.overload
def Slerp(alpha: float, v1: Vec4h, v2: Vec4h) -> Vec4h:
    ...
@typing.overload
def Slerp(arg0: float, arg1: Quatd, arg2: Quatd) -> Quatd:
    ...
@typing.overload
def Slerp(arg0: float, arg1: Quatf, arg2: Quatf) -> Quatf:
    ...
@typing.overload
def Slerp(arg0: float, arg1: Quath, arg2: Quath) -> Quath:
    ...
@typing.overload
def Sqr(arg0: float) -> float:
    ...
@typing.overload
def Sqr(arg0: float) -> float:
    ...
@typing.overload
def Sqrt(arg0: float) -> float:
    ...
@typing.overload
def Sqrt(arg0: float) -> float:
    ...
