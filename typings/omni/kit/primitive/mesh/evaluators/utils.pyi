from __future__ import annotations
import carb as carb
import math as math
from numbers import Number
import pxr.Gf
from pxr import Gf
__all__: list[str] = ['Gf', 'Number', 'build_int_slider', 'carb', 'generate_circle_points', 'generate_disk', 'generate_plane', 'get_int_setting', 'inverse_u', 'inverse_uv', 'inverse_v', 'math', 'modify_winding_order', 'transform_point']
def _save_settings(model, setting):
    ...
def build_int_slider(name, setting, default_value, min_value, max_value, tooltip = None):
    ...
def generate_circle_points(up_axis, num_points, delta, center_point = ...) -> typing.Tuple[typing.List[pxr.Gf.Vec3f], typing.List[pxr.Gf.Vec2f]]:
    ...
def generate_disk(center_point: pxr.Gf.Vec3f, u_patches: int, v_patches: int, origin: pxr.Gf.Vec3f, half_scale: float, up_axis = 'Y') -> typing.Tuple[typing.List[pxr.Gf.Vec3f], typing.List[pxr.Gf.Vec3f], typing.List[pxr.Gf.Vec2f], typing.List[int], typing.List[int]]:
    ...
def generate_plane(origin, half_scale, u_patches, v_patches, up_axis):
    ...
def get_int_setting(key, default_value):
    ...
def inverse_u(uv) -> pxr.Gf.Vec2f:
    ...
def inverse_uv(uv) -> pxr.Gf.Vec2f:
    ...
def inverse_v(uv) -> pxr.Gf.Vec2f:
    ...
def modify_winding_order(face_counts, face_indices):
    ...
def transform_point(point: pxr.Gf.Vec3f, origin: pxr.Gf.Vec3f, half_scale: float) -> pxr.Gf.Vec3f:
    ...
